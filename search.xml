<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于axios各种请求方式的传参总结</title>
      <link href="/2021/102150482.html"/>
      <url>/2021/102150482.html</url>
      
        <content type="html"><![CDATA[<h1 id="axios-传参"><a href="#axios-传参" class="headerlink" title="axios 传参"></a>axios 传参</h1><p>这几天我在写我的 vue 项目后台接口，因为是第一次写所以我写遇到了一些小问题,axios 各种请求方式的传参数。基本将常用的请求方式都用过了所以现在总结一下。</p><h2 id="get-请求方式"><a href="#get-请求方式" class="headerlink" title="get 请求方式"></a>get 请求方式</h2><p>get 请求方式我使用的是 Params 进行传参,前端代码:</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const &#123; data: res &#125; = await this.$http.get(`/goods/query`, &#123;  params: &#123;    query: this.query  &#125;&#125;)</code></pre><p>然后后台接口接受传参</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let query = req.query.query</code></pre><h2 id="post-请求方式"><a href="#post-请求方式" class="headerlink" title="post 请求方式"></a>post 请求方式</h2><p>前端传参</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const &#123; data: res &#125; = await this.$http.post('/goods/increase', this.increaseInfo)</code></pre><p>接口接收参数</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let name = req.body.namelet price = req.body.pricelet type = req.body.typelet area = req.body.area</code></pre><h2 id="put-请求"><a href="#put-请求" class="headerlink" title="put 请求"></a>put 请求</h2><p>前端传参<br>第一种办法</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const &#123; data: res &#125; = await this.$http.put(`/goods/info/`, this.editInfo)</code></pre><p>后端接口</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let id = req.body.idid = parseInt(id)let name = req.body.namelet price = req.body.priceprice = parseInt(price)</code></pre><p>第二种办法<br>前端传参</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const &#123; data: res &#125; = await this.$http.put(`/goods/status/$&#123;numId&#125;/$&#123;status&#125;`)</code></pre><p>后端接口</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">router.put('/status/:id/:status', function (req, res) &#123;  goods.updateStatus(req, res)&#125;)let id = req.params.idlet status = req.params.status</code></pre><h2 id="delete-请求"><a href="#delete-请求" class="headerlink" title="delete 请求"></a>delete 请求</h2><p>前端传参</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const &#123; data: res &#125; = await this.$http.delete(`/goods/delete`, &#123;  data: &#123;    id: numId  &#125;&#125;)</code></pre><p>后端接口</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">req.body.id</code></pre><p>这样就可以简单的获取到了前端传过来的参数，有很多办法可以进行传参这只是我刚开始使用的方法，肯定有不好的地方。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Node写接口vue跨域问题Cors</title>
      <link href="/2021/101650482.html"/>
      <url>/2021/101650482.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue-跨域，同源策略"><a href="#vue-跨域，同源策略" class="headerlink" title="vue 跨域，同源策略"></a>vue 跨域，同源策略</h1><h2 id="同源策略："><a href="#同源策略：" class="headerlink" title="同源策略："></a>同源策略：</h2><p>同原策略就是协议，域名，端口号必须完全相同。因为前端经常会用到 Ajax 请求接口中的数据，Ajax 就遵循同源策略。所以我们就需要解决这个问题。因为我最近在用 node 写接口，然后用 vue 写前端进行渲染。遇到了这个跨域问题，所以我在网上找了很多解决方案。我只能说我现在不是很能理解这些解决方案的意思，以后慢慢理解。</p><h2 id="node-接口端："><a href="#node-接口端：" class="headerlink" title="node 接口端："></a>node 接口端：</h2><pre class=" language-lang-javascript"><code class="language-lang-javascript">// 处理cors跨域/* 全系统设置跨域处理 */// CORS & Preflight requestapp.use((req, res, next) => &#123;  if (req.path !== '/' && !req.path.includes('.')) &#123;    res.set(&#123;      'Access-Control-Allow-Credentials': true,      'Access-Control-Allow-Origin': req.headers.origin || '*',      'Access-Control-Allow-Headers': 'X-Requested-With,Content-Type',      'Access-Control-Allow-Methods': 'PUT,POST,GET,DELETE,OPTIONS',      'Content-Type': 'application/json; charset=utf-8'    &#125;)  &#125;  req.method === 'OPTIONS' ? res.status(204).end() : next()&#125;)</code></pre><h2 id="vue-端："><a href="#vue-端：" class="headerlink" title="vue 端："></a>vue 端：</h2><pre class=" language-lang-javascript"><code class="language-lang-javascript">import axios from 'axios'import qs from 'qs'axios.defaults.withCredentials = true // 允许跨域设置，不然可能因为拿不到cookie而报错axios.defaults.baseURL = 'http://localhost:3000/' /*这里的地址就是刚刚启起来的服务器地址,就是node端服务器的地址 *//*请求拦截*/axios.interceptors.request.use(  config => &#123;    if (config.meth === 'post' && !(config.data instanceof FormData)) &#123;      config.headers = &#123;        'Content-Type': 'application/x-www-form-urlencoded'      &#125;      config.data = qs.stringify(config.data, &#123;        arrayFormat: 'repeat'      &#125;) /*这里是，后端要求传数组的时候做的设置，以前出过错*/    &#125;    return config  &#125;,  error => &#123;    return Promise.reject(error)  &#125;)/* 响应拦截 */axios.interceptors.response.use(  res => &#123;    /*可在这里根据返回的状态码做一些拦截操作*/    return res  &#125;,  err => &#123;    return Promise.resolve(err)  &#125;)export default axios /*记得导出*/</code></pre><p>这两个设置完之后应该就不会出现跨域的问题，反正我测试的接口现在可以用 axios 请求到数据了，虽然我不是非常理解为什么这样写。但是有需求急迫解决这个问题的可以借鉴一下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2021/10121.html"/>
      <url>/2021/10121.html</url>
      
        <content type="html"><![CDATA[<h1 id="javascript-的设计模式"><a href="#javascript-的设计模式" class="headerlink" title="javascript 的设计模式"></a>javascript 的设计模式</h1><h2 id="模块化模式"><a href="#模块化模式" class="headerlink" title="模块化模式"></a>模块化模式</h2><p>模块化模式：让内部成员不外泄到全局中，将内部信息封装成一个模块。只能通过特定的方法才可以进行访问内部成员信息。比如说购物车中数组是不能直接让外部进行访问的，只能通过其域中特定的方法才可以进行访问。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var buy = (function () &#123;  var buyList = []  //增加购物车数据方法  function addItem(values) &#123;    buyList.push(values)  &#125;  //得到购物车数据数量的方法  function getItem() &#123;    conlose.log(buyList.length)  &#125;  return &#123;    addItem: addItem,    getItem: getItem  &#125;&#125;)()buy.addItem(&#123;  name: 'one',  price: 1&#125;)buy.addItem(&#123;  name: 'two',  price: 2&#125;)buy.getItem() //2console.log(buy.buyList) //这个是不可以直接访问的,直接访问的结果是undefined</code></pre><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式是一种十分常用但却相对而言比较简单的设计模式。它是指在一个类只能有一个实例，即使多次实例化该类，也只返回第一次实例化后的实例对象。单例模式不仅能减少不必要的内存开销, 并且在减少全局的函数和变量冲突也具有重要的意义。<br>使用闭包实现单例模式</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let Create = function () &#123;  let instance = null  return function (name) &#123;    this.name = name    if (instance) &#123;      return instance    &#125;    return (instance = this)  &#125;&#125;Create.prototype.getName = function () &#123;  console.log(this.name)&#125;let xiaoming = new Create('xiaoming')// console.log(xiaoming.getName());xiaoming.getName() //xiaominglet xiaoliu = new Create('xiaoliu')// console.log(xiaoliu.getName());xiaoliu.getName() //xiaoming</code></pre><p>利用一个变量 instance 判断是否已经创建实例，如果之前没有创建实例就将 this 传给 instance。当第二次创建实例的时候，虽然向构造函数中传入参数了但是因为 instance 已经存在 所以返回的还是上一次创建的实例。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对象方法</title>
      <link href="/2021/10101.html"/>
      <url>/2021/10101.html</url>
      
        <content type="html"><![CDATA[<h1 id="js-object-的内置方法"><a href="#js-object-的内置方法" class="headerlink" title="js object 的内置方法"></a>js object 的内置方法</h1><h2 id="Object-assign-用法"><a href="#Object-assign-用法" class="headerlink" title="Object.assign()用法"></a>Object.assign()用法</h2><p>·对象的拷贝<br>该方法用于将所有可枚举属性的值从一个或多个源对象（sources）分配到目标对象（target），并返回目标对象。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let target = &#123; a: 1, b: 2 &#125;let sources1 = &#123; a: 2, b: 3 &#125;let sources2 = &#123; a: 3, b: 4 &#125;let obj = Object.assign(target, sources1, sources2)console.log(obj)//a:3 b:4</code></pre><p>注意：</p><p>1、源对象属性与目标对象属性不同，则会被拷贝到目标对象中;<br>2、如果目标对象和源对象有相同的属性，目标对象的属性值会被源对象的属性值覆盖掉;<br>3、如果有多个源对象有相同的属性，那么目标对象的属性将会被最后一个源对象属性覆盖。</p><p>使用这个方法进行拷贝进行的是深拷贝，继承和枚举的属性不可以使用 assign 进行拷贝</p><h2 id="Object-defineProperty-用法"><a href="#Object-defineProperty-用法" class="headerlink" title="Object.defineProperty()用法"></a>Object.defineProperty()用法</h2><p>·该方法允许精确地添加或修改对象的属性。通过赋值操作添加的普通属性是可枚举的，在枚举对象属性时会被枚举到（for…in 或 Object.keys 方法），可以改变这些属性的值，也可以删除这些属性。这个方法允许修改默认的额外选项（或配置）。默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改（immutable）的。<br>·使用方法:</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const target = &#123;&#125;Object.defineProperty(target, 'foo', &#123;  configurable: false,  writable: false,  vakue: 'Test'&#125;)</code></pre><p>上面的代码就给 target 这个对象添加一个 foo 属性，而且这个属性的值为 Test。当 configurable 为 false 的时候这个属性不可以改变。当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符改变。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue-music-pc项目</title>
      <link href="/2021/092950482.html"/>
      <url>/2021/092950482.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue-music-pc-项目"><a href="#vue-music-pc-项目" class="headerlink" title="vue-music-pc 项目"></a>vue-music-pc 项目</h1><ul><li>这个项目是我自己动手做的第一个项目，完全靠自己做的，所以 css 写的不好，有一些逻辑写的也不是很好，后来再慢慢去优化吧，项目还没有上线。但是我的代码都放到了 GitHub 和 gitee 上了，一些东西还是有帮助的。</li><li>这里是 GitHub 的地址 <a href="https://github.com/wuyang147258/vue-music-pc">vue 网易云(github)</a> 这个是 gitee 的地址 <a href="https://gitee.com/ycwuyang/vue-music-pc">vue 网易云(gitee)</a> 这个是我用的后台接口 <a href="https://binaryify.github.io/NeteaseCloudMusicApi/#/">网易云后台接口</a></li><li>技术栈：vue+vuex+element-ui</li></ul><h2 id="开发前的准备："><a href="#开发前的准备：" class="headerlink" title="开发前的准备："></a>开发前的准备：</h2><ul><li>在我们进行痛快淋漓的写业务逻辑之前必然是需要配置一些插件依赖什么的。这里我 ui 框架是用的 element-ui 这个是开源的框架，功能还是比较齐全的。在 vue-cli 的使用方法我已经给大家找好了。<a href="https://blog.csdn.net/u013350495/article/details/103533320?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163288625116780264060046%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163288625116780264060046&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-103533320.first_rank_v2_pc_rank_v29&amp;utm_term=vue-ui%E6%8C%89%E9%9C%80%E5%AF%BC%E5%85%A5element-ui&amp;spm=1018.2226.3001.4187">按需导入 element-ui</a> 还有的就是 axios 库，这个比较简单安装一下就可以了。下面最重要的一点也是我踩过的坑，我最想给大家说的。就是在你访问后台接口的时候会出现跨域的问题，大家可能以前也遇到过满难受的。这是我用的解决方案源码：</li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">import axios from 'axios'import qs from 'qs'axios.defaults.withCredentials = true // 允许跨域设置，不然可能因为拿不到cookie而报错axios.defaults.baseURL = 'http://localhost:3000/' /*这里的地址就是刚刚启起来的服务器地址  *//*请求拦截*/axios.interceptors.request.use(  config => &#123;    if (config.meth === 'post' && !(config.data instanceof FormData)) &#123;      config.headers = &#123;        'Content-Type': 'application/x-www-form-urlencoded'      &#125;      config.data = qs.stringify(config.data, &#123;        arrayFormat: 'repeat'      &#125;) /*这里是，后端要求传数组的时候做的设置，以前出过错*/    &#125;    return config  &#125;,  error => &#123;    return Promise.reject(error)  &#125;)/* 响应拦截 */axios.interceptors.response.use(  res => &#123;    /*可在这里根据返回的状态码做一些拦截操作*/    return res  &#125;,  err => &#123;    return Promise.resolve(err)  &#125;)export default axios /*记得导出*/</code></pre><p>解决了以上问题之后我们就可以愉快的进行项目开发了！！!</p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>登录功能的思路很简单。第一先设置一个路由导航，阻止用户不进行登录就进入主页。第二获取后台接口进行登录(我使用了手机验证码登录和密码登录)，成功登录之后需要获取一个登录状态要不然后面的一些功能可能没有办法使用。</p><h2 id="歌曲实现播放"><a href="#歌曲实现播放" class="headerlink" title="歌曲实现播放"></a>歌曲实现播放</h2><p>在 pc 端上面怎么实现歌曲播放呢，我首先想到的是 audio 标签。然后就想要将音乐的 url 放到 audio 的 src 上应该就可以进行播放了。这是我当时写的时候的思路。因为组件的复用，所以我把 audio 放到了主页上，这样不管以后再增加什么歌曲或者歌单将这个歌曲的 id 存入到 vuex 中就可以拿到歌曲的 url，然后通过 ref 就可以设置 audio 的 src 进行歌曲的播放了。组件的复用还可以，省了不少麻烦。</p><h2 id="歌曲详情页面-歌词滚动实现"><a href="#歌曲详情页面-歌词滚动实现" class="headerlink" title="歌曲详情页面(歌词滚动实现)"></a>歌曲详情页面(歌词滚动实现)</h2><p>因为其他的东西不算特别难，业务逻辑基本都是一样的都是获取后台接口的数据然后进行渲染，没有什么稀奇的东西。我感觉这个歌词的滚动还算比较难，因为我在做的时候费了不少力气，也看了不少人的博客。这个解决方案是我看一个教学视频上看到的。<br>思路就是将后台获取到的歌词数据处理成一个时间段一句歌词的格式。然后获取当前歌曲播放的时间让这个时间大于上一句歌词的时间小于下一句歌词的时间，思路就是这样。下面附上歌词处理的代码，后面还要加上 css 的动画滚动。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//这里是处理歌词格式和实现歌词滚动的代码//处理歌词方法       formatTimeToSec(value)&#123;                    let arr = value.split(':');                    return (Number(arr[0]*60) +  Number(arr[1])).toFixed(1);            &#125;,   //处理歌词方法   proLyric(lyric)&#123;     //利用正则处理歌词                        // console.log(lyric)                        let re=/\[([^\]]+)\]([^\[]+)/g                        var result=[];                        lyric.replace(re,($0,$1,$2)=>&#123;                            result.push(&#123;"time":this.formatTimeToSec($1),"lyric":$2&#125;)                        &#125;)                        this.songLyric=result   &#125;,   //实现歌词滚动   //实现歌词滚动            listenLyricIndex()&#123;                //清除之前存在的计时器                clearInterval(this.timer)                this.timer=setInterval(()=>&#123;                    for(var i=0;i<this.songLyric.length;i++)&#123;                        if(this.$store.state.currentTime>this.songLyric[this.songLyric.length-1].time)&#123;                            this.lyricIndex=this.songLyric.length-1                            break;                        &#125;                        if(this.$store.state.currentTime>this.songLyric[i].time && this.$store.state.currentTime<this.songLyric[i+1].time)&#123;                            this.lyricIndex=i                        &#125;                    &#125;                &#125;,500)            &#125;,            //关闭定时器            cancelLyriIdex()&#123;                clearInterval(this.timer)            &#125;,</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客小试牛刀</title>
      <link href="/2021/092839553.html"/>
      <url>/2021/092839553.html</url>
      
        <content type="html"><![CDATA[<h1 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h1><h2 id="一个前端小白的成长经历"><a href="#一个前端小白的成长经历" class="headerlink" title="一个前端小白的成长经历"></a>一个前端小白的成长经历</h2><ul><li>见证了自己的成长，真的很幸福。从大一到现在一直一个人在自学，到现在可以做一些<br>有趣的东西，可以做一些好玩的东西感觉真好。虽然自己出了很多 bug，但是基本上也都<br>上网进行了解决，也有看见困难就退缩的时候，比如这个博客一开始我就没有搭建好，<br>然后放弃了搭建。几天后我又重拾进行搭建。现在终于成功了，所以不是办不到，只是<br>看自己想不想干了。</li></ul><h2 id="可爱的小猫"><a href="#可爱的小猫" class="headerlink" title="可爱的小猫"></a>可爱的小猫</h2><p>以后在能养活自己的前提养一只小猫！<br><img src="https://th.bing.com/th/id/R.f18f12a4ba5ae21a01bd8a8ecae7fa42?rik=5S8Pjv29%2fYLEnA&amp;pid=ImgRaw&amp;r=0" alt=""></p><h2 id="vue-网易云"><a href="#vue-网易云" class="headerlink" title="vue 网易云"></a>vue 网易云</h2><p>这是自己做的 pc 端网易云，完全自己做。我样式搞得不是很好，需要重新加工。<br>这是 GitHub 地址 <a href="https://github.com/wuyang147258/vue-music-pc">vue 网易云</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 成长经历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/092816107.html"/>
      <url>/2021/092816107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
