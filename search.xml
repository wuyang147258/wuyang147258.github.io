<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue虚拟dom源码解析</title>
      <link href="/2021/12071.html"/>
      <url>/2021/12071.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue虚拟dom源码解析"><a href="#vue虚拟dom源码解析" class="headerlink" title="vue虚拟dom源码解析"></a>vue虚拟dom源码解析</h1><p>学过vue的大家都知道，vue使用的是虚拟dom。这是我对虚拟dom的理解和手写自己的虚拟dom。  </p><h3 id="什么是虚拟dom"><a href="#什么是虚拟dom" class="headerlink" title="什么是虚拟dom"></a>什么是虚拟dom</h3><p>什么是虚拟dom<br>用js模拟一颗dom树,放在浏览器内存中.当你要变更时,虚拟dom使用diff算法进行新旧虚拟dom的比较,将变更放到变更队列中,反应到实际的dom树,减少了dom操作.</p><p>虚拟DOM将DOM树转换成一个JS对象树,diff算法逐层比较,删除,添加操作,但是,如果有多个相同的元素,可能会浪费性能,所以,react和vue-for引入key值进行区分.  </p><p>为什么要使用虚拟dom：</p><p>在传统开发中，用JQuery或者原生的JavaScript DOM操作函数对DOM进行频繁操作的时候，浏览器要不停的渲染新的DOM树，导致页面看起来非常卡顿。而Virtual DOM则是虚拟DOM的英文，简单来说，他就是一种可以预先通过JavaScript进行各种计算，把最终的DOM操作计算出来并优化，由于这个DOM操作属于预处理操作，并没有真实的操作DOM，所以叫做虚拟DOM。最后在计算完毕才真正将DOM操作提交，将DOM操作变化反映到DOM树上。</p><h3 id="手写vnode函数"><a href="#手写vnode函数" class="headerlink" title="手写vnode函数"></a>手写vnode函数</h3><p>vnode函数返回一个虚拟dom的数据格式：  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">/* vnode 函数 返回包含虚拟节点基本数据结构的对象 */export default function(sel, data, children, text, elm) &#123;    return &#123;        sel,        data,        children,        text,        elm    &#125;&#125;</code></pre><h3 id="手写一个简易版的h函数"><a href="#手写一个简易版的h函数" class="headerlink" title="手写一个简易版的h函数"></a>手写一个简易版的h函数</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">import vnode from "./vnode"; //导入vnode函数// 编写一个低配版的h函数，这个函数必须接受3个参数，缺一不可// 相当于它的重置功能较弱// 也就是说，调用的时候形态必须是下面的三种之一/*  形态①：h('div', &#123;&#125;, '文字')  形态②：h('div', &#123;&#125;, [])  形态③：h('div', &#123;&#125;, h())*/export default function(sel, data, c) &#123;    //检查这三个元素必须全部传入，没有的话就抛出一个错误    if (arguments.length !== 3)        throw new Error('没有传入符合的三个参数')    if (typeof c === 'string' || typeof c === 'number') &#123;        //证明此时传入的符合第一种情况,返回一个vnode        return vnode(sel, data, undefined, c, undefined)    &#125; else if (Array.isArray(c)) &#123;        //此时c为一个数组，符合第二种情况        let children = []            // 遍历c        for (let i = 0; i < c.length; i++) &#123;            // 检查 c[i] 必须是个对象            if (!(typeof c[i] === 'object' && c[i].hasOwnProperty('sel')))                throw new Error('传入的数组参数中有项不是 h 函数')                    // 这里不用执行 c[i]，因为你的调用语句中已经有了执行//每一个数组中都是一个一个的h函数 那时候就已经进行了调用                    // 此时只要收集好就行了            children.push(c[i])        &#125;        // 循环结束了，就说明children收集完毕了，此时可以返回虚拟节点了，它是有children属性的        return vnode(sel, data, children, undefined, undefined)    &#125; else if (typeof c === 'object' && c.hasOwnProperty('sel')) &#123;        //证明此时是第三种情况        let children = [c]        return vnode(sel, data, children, undefined, undefined)    &#125; else &#123;        throw new Error('参数错误')    &#125;&#125;</code></pre><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">/** src/index.js */import h from './mysnabbdom/h'const myVNode1 = h('div', &#123;&#125;, [    h('p', &#123;&#125;, '哈哈'),    h('p', &#123;&#125;, '嘻嘻'),    h('p', &#123;&#125;, '呵呵'),    h('p', &#123;&#125;, [h('span', &#123;&#125;, 'aa'), h('span', &#123;&#125;, 'bb')]),    h('p', &#123;&#125;, h('span', &#123;&#125;, 'A'))])const myVNode2 = h('ul', &#123;&#125;, [    h('li', &#123;&#125;, '牛奶'),    h('li', &#123;&#125;, '咖啡'),    h('li', &#123;&#125;, [h('div', &#123;&#125;, [h('p', &#123;&#125;, '可口可乐'), h('p', &#123;&#125;, '百事可乐')])]),    h('li', &#123;&#125;, h('p', &#123;&#125;, '雪碧'))])console.log(myVNode1)</code></pre><p>测试结果：  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">&#123;sel: 'div', data: &#123;…&#125;, children: Array(5), text: undefined, elm: undefined&#125;children: Array(5)0: &#123;sel: 'p', data: &#123;…&#125;, children: undefined, text: '哈哈', elm: undefined&#125;1: &#123;sel: 'p', data: &#123;…&#125;, children: undefined, text: '嘻嘻', elm: undefined&#125;2: &#123;sel: 'p', data: &#123;…&#125;, children: undefined, text: '呵呵', elm: undefined&#125;3: &#123;sel: 'p', data: &#123;…&#125;, children: Array(2), text: undefined, elm: undefined&#125;4: &#123;sel: 'p', data: &#123;…&#125;, children: Array(1), text: undefined, elm: undefined&#125;length: 5[[Prototype]]: Array(0)data: &#123;&#125;elm: undefinedsel: "div"text: undefined[[Prototype]]: Object</code></pre><h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h3><p><strong><font color="red">diff算法心得</font></strong></p><p>1.最小量更新太厉害啦!真的是最小量更新!当然，key很重要。key是这个节点的唯一标识，告诉diff算法，在更改前后它们是同一个DOM节点<br>2.只有是同一个虚拟节点，才进行精细化比较，否则就是暴力删除旧的、插入新的。延伸问题:如何定义是同一个虚拟节点?答:选择器相同且key相同。<br>3.只进行同层比较，不会进行跨层比较。即使是同一片虚拟节点，但是跨层了。对不起，精细化比较不diff你。而是暴力删除旧的、然后插入新的。</p><p>上面的代码只是让dom元素变成了js对象格式的数据，并没有什么作用。所以我们就需要使用diff算法，patch函数进行虚拟dom的上树。 </p><p><img src="https://img-blog.csdnimg.cn/20210112092054788.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdodWFuMTAyMA==,size_16,color_FFFFFF,t_70#pic_center" alt="image-20211207160441496"></p><p>手写<em>createElement</em> 函数  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">// createElement 函数// 真正创建节点 将 vnode 创建为 DOM// 是孤儿节点，不进行插入export default function createElement(vnode) &#123;    // 创建一个 DOM 节点，这个节点现在还是孤儿节点    let domNode = document.createElement(vnode.sel)        // 有子节点还是有文本？    if (        vnode.text !== '' && (vnode.children === undefined || vnode.children.length === 0)    ) &#123;        // 它内部是文字        domNode.innerText = vnode.text    &#125; else if (Array.isArray(vnode.children) && vnode.children.length > 0) &#123;        // 它内部是子节点，就要递归创建节点        for (let i = 0; i < vnode.children.length; i++) &#123;            // 得到当前这个 child            let ch = vnode.children[i]                // 创建DOM，一旦调用createElement意味着：创建出DOM了，并且它的elm属性指向了创建出的DOM，但是还没有上树，是一个孤儿节点            let chDom = createElement(ch)                // 上树            domNode.appendChild(chDom)        &#125;    &#125;    // 补充 elm 属性    vnode.elm = domNode        // 返回 elm，elm是一个纯dom对象    return vnode.elm&#125;</code></pre><p>手写patch函数  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">// patch 函数import vnode from './vnode'import createElement from './createdElement'export default function patch(oldVnode, newVnode) &#123;    // 判断传入的第一个参数，是DOM节点还是虚拟节点？    if (oldVnode.sel === '' || oldVnode.sel === undefined) &#123;        // 传入的第一个参数是DOM节点，此时要包装为虚拟节点        oldVnode = vnode(            oldVnode.tagName.toLowerCase(), &#123;&#125;, [],            undefined,            oldVnode        )    &#125;    console.log(oldVnode, newVnode)        // 判断 oldVnode和newVnode 是不是同一个节点    if (oldVnode.key === newVnode.key && oldVnode.sel === newVnode.sel) &#123;        console.log('是同一个节点')    &#125; else &#123;        console.log('不是同一个节点，暴力插入新的，删除旧的')        let newVnodeElm = createElement(newVnode)        if (oldVnode.elm && newVnodeElm) &#123;            // 插入到老节点之前            oldVnode.elm.parentNode.insertBefore(newVnodeElm, oldVnode.elm)        &#125;        // 删除老节点        oldVnode.elm.parentNode.removeChild(oldVnode.elm)    &#125;&#125;</code></pre><p>测试  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">// 测试代码import h from './mysnabbdom/h'import patch from './mysnabbdom/patch'const myVnode1 = h('ul', &#123;&#125;, [    h('li', &#123;&#125;, '牛奶'),    h('li', &#123;&#125;, '咖啡'),    h('li', &#123;&#125;, [h('div', &#123;&#125;, [h('p', &#123;&#125;, '可口可乐'), h('p', &#123;&#125;, '百事可乐')])]),    h('li', &#123;&#125;, h('p', &#123;&#125;, '雪碧'))])const container = document.getElementById('container')patch(container, myVnode1)const btn = document.getElementById('btn')const myVnode2 = h('section', &#123;&#125;, [    h('h1', &#123;&#125;, '我是新的h1'),    h('h2', &#123;&#125;, '我是新的h2')])btn.onclick = function() &#123;    patch(myVnode1, myVnode2)&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/20210112092211795.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdodWFuMTAyMA==,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>当oldVnode和newVnode是一个节点的时候，判断内存中是否是同一个对象。是的话就什么都不用做。不是的话判断newVnode是否有text属性。有的话，判断新节点与旧节点中的text是否相同。相同什么都不用做，不同的话将旧节点的text改为新节点的text  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">import createElement from "./createdElement";export default function pathchNode(oldNode, newNode) &#123;    //判断新节点和旧节点是否是内存中同一个对象，是的话不用做任何操作    if (oldNode === newNode) return        //判断新节点是否含有text属性    if (newNode.text != undefined && (newNode.children == undefined || newNode.children.length == 0)) &#123;        //此时新节点中有text属性：        //判断新节点中text属性和旧节点中text属性是否相同        if (newNode.text != oldNode.text) &#123;            //此时新节点中的text属性和旧节点中的text属性不同            oldNode.elm.innerText = newNode.text        &#125;    &#125; else &#123;        //此时新节点中有chilren属性    &#125;&#125;</code></pre><p>这时候有text的情况就处理完毕了，然后就可以处理新节点有chilren的情况了。此时要判断旧节点中是否也有children属性，如果有的话就比较复杂难处理。此时就需要用到四种命中查找。没有chiilren属性的话，直接清空旧节点的text属性并把新节点的children添加到dom中。  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">export default function pathchNode(oldNode, newNode) &#123;    //判断新节点和旧节点是否是内存中同一个对象，是的话不用做任何操作    if (oldNode === newNode) return        //判断新节点是否含有text属性    if (newNode.text != undefined && (newNode.children == undefined || newNode.children.length == 0)) &#123;        //此时新节点中有text属性：      ...    &#125; else &#123;        //此时新节点中有chilren属性        //判断老节点中是否含有chilren属性        if (oldNode.children !== undefined && oldNode.children.length > 0) &#123;            //此时旧节点中也有chilren属性            //...        &#125; else &#123;            // 老的vnode没有children，新的有            // 清空老vnode的内容            oldVnode.elm.innerText = ''                //遍历新的子节点并上树            for (let i = 0; i < newNode.children.length; i++) &#123;                let dom = createElement(newNode.children[i])                    //dom上树                oldNode.elm.appendChild(dom)            &#125;        &#125;    &#125;&#125;</code></pre><p>当旧节点中也有children属性的时候， </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">import createElement from "./createdElement";export default function pathchNode(oldNode, newNode) &#123;    //判断新节点和旧节点是否是内存中同一个对象，是的话不用做任何操作    if (oldNode === newNode) return        //判断新节点是否含有text属性    if (newNode.text != undefined && (newNode.children == undefined || newNode.children.length == 0)) &#123;       ...    &#125; else &#123;        //此时新节点中有chilren属性        //判断老节点中是否含有chilren属性        if (oldNode.children !== undefined && oldNode.children.length > 0) &#123;            //此时旧节点中也有chilren属性            //定义一个指针un            let un = 0            for (let i = 0; i < newNode.children.length; i++) &#123;                //创建新节点的具体孩子节点                let newch = newNode.children[i]                    //定义标识，用于判断是否含有此孩子                let isExist = false                for (let j = 0; j < oldNode.children.length; j++) &#123;                    let oldch = oldNode.children[j]                        //进行比对                    if (newch.sel == oldch.sel && newch.key == oldch.key) &#123;                        //此时新节点中的孩子与旧节点中的孩子相同                        isExist = true                    &#125;                    if (!isExist) &#123;                        //此时在旧节点中没有找到新节点中的chilren 证明这个chilren是新增加的元素                        let dom = createElement(newch)                        newch.elm = dom                            //判断un是否小于旧节点孩子长度，小于证明在中间添加，不小于在最后面追加                        if (un < oldNode.children.length) &#123;                            oldVnode.elm.insertBefore(dom, oldVnode.children[un].elm)                        &#125; else &#123;                            //在最后追加                            oldNode.elm.appendChild(dom)                        &#125;                    &#125; else &#123;                        //没有找到不一样的就一直指针下移                        un++                    &#125;                &#125;            &#125;        &#125; else &#123;            // 老的vnode没有children，新的有           ...        &#125;    &#125;&#125;</code></pre><p>//此时只适用于新增节点的逻辑，更新节点和删除节点都不可以。所以我们需要使用四种查找策略。  </p><p>四种命中查找（经典的diff算法优化策略）：<br>① 新前与旧前<br>② 新后与旧后<br>③ 新后与旧前（<code>此种命中，涉及移动节点，那么旧前指向的节点，移动到旧后之后</code>）<br>④ 新前与旧后（<code>此种命中，涉及移动节点，那么旧后指向的节点，移动到旧前之前</code>）</p><p><img src="https://img-blog.csdnimg.cn/20210112092502679.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdodWFuMTAyMA==,size_16,color_FFFFFF,t_70#pic_center" alt></p><p><img src="https://img-blog.csdnimg.cn/20210112092531632.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdodWFuMTAyMA==,size_16,color_FFFFFF,t_70#pic_center" alt></p><p><img src="https://img-blog.csdnimg.cn/20210112092531699.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdodWFuMTAyMA==,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>情况描述：一开是旧前可以新前进行比对，前两个符合。然后指针下移，旧前到了c位置，新前到了D位置。这时候不符合第一个查找。</p><p>执行第二个查找，新后与旧后，发现也不匹配。执行第三个查找，新后与旧前，还是不符合。执行第四个查找，新前与旧后，还是不符合。但是这时候并没有结束，开始在旧节点中遍历查找新前当前所在的位置(也就是D)，找到了然后设置为undefined。新前指针下移，不符合循环条件。这时候在旧前与旧后间的节点都是要删除的节点。</p><p><img src="https://img-blog.csdnimg.cn/20210112092641384.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdodWFuMTAyMA==,size_16,color_FFFFFF,t_70#pic_center" alt></p><p><img src="https://img-blog.csdnimg.cn/20210112092641368.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdodWFuMTAyMA==,size_16,color_FFFFFF,t_70#pic_center" alt></p><p><img src="https://img-blog.csdnimg.cn/20210112092641373.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdodWFuMTAyMA==,size_16,color_FFFFFF,t_70#pic_center" alt></p><p><img src="https://img-blog.csdnimg.cn/20210112092641365.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdodWFuMTAyMA==,size_16,color_FFFFFF,t_70#pic_center" alt></p><pre class=" language-lang-javascript"><code class="language-lang-javascript">// updateChildren.jsimport createElement from './createdElement'import patchVnode from './patchNode'// 判断是否是同一个虚拟节点function checkSameVnode(a, b) &#123;    return a.sel === b.sel && a.key === b.key&#125;export default function updateChildren(parentElm, oldCh, newCh) &#123;    // console.log('我是updateChildren')    // console.log(oldCh, newCh)    let oldStartIdx = 0 // 旧前    let newStartIdx = 0 // 新前    let oldEndIdx = oldCh.length - 1 // 旧后    let newEndIdx = newCh.length - 1 // 新后    let oldStartVnode = oldCh[oldStartIdx] // 旧前节点    let oldEndVnode = oldCh[oldEndIdx] // 旧后节点    let newStartVnode = newCh[newStartIdx] // 新前节点    let newEndVnode = newCh[newEndIdx] // 新后节点    let keyMap = null        // console.log(oldStartIdx, newEndIdx)        // 开始循环    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) &#123;        // console.log('☆')        // 首先不是判断命中，而是要掠过已经加undefined标记的东西        if (oldStartVnode === null || oldCh[oldStartIdx] === undefined) &#123;            oldStartVnode = oldCh[++oldStartIdx]        &#125; else if (oldEndVnode === null || oldCh[oldEndIdx] === undefined) &#123;            oldEndVnode = oldCh[--oldEndIdx]        &#125; else if (newStartVnode === null || newCh[newStartIdx] === undefined) &#123;            newStartVnode = newCh[++newStartIdx]        &#125; else if (newEndVnode === null || newCh[newEndIdx] === undefined) &#123;            newEndVnode = newCh[--newEndIdx]        &#125; else if (checkSameVnode(oldStartVnode, newStartVnode)) &#123;            // 新前和旧前            console.log('① 新前和旧前命中')            patchVnode(oldStartVnode, newStartVnode)            oldStartVnode = oldCh[++oldStartIdx]            newStartVnode = newCh[++newStartIdx]        &#125; else if (checkSameVnode(oldEndVnode, newEndVnode)) &#123;            // 新后和旧后            console.log('② 新后和旧后命中')            patchVnode(oldEndVnode, newEndVnode)            oldEndVnode = oldCh[--oldEndIdx]            newEndVnode = newCh[--newEndIdx]        &#125; else if (checkSameVnode(oldStartVnode, newEndVnode)) &#123;            // 新后和旧前            console.log('③ 新后和旧前命中')            patchVnode(oldStartVnode, newEndVnode)                // 当③新后与旧前命中的时候，此时要移动节点。移动新后指向的这个节点到老节点旧后的后面                // 如何移动节点？只要你插入一个已经在DOM树上的节点，它就会被移动            parentElm.insertBefore(oldStartVnode.elm, oldEndVnode.elm.nextSibling)            oldStartVnode = oldCh[++oldStartIdx]            newEndVnode = newCh[--newEndIdx]        &#125; else if (checkSameVnode(oldEndVnode, newStartVnode)) &#123;            // 新前和旧后            console.log('④ 新前和旧后命中')            patchVnode(oldEndVnode, newStartVnode)                // 当④新前与旧后命中的时候，此时要移动节点。移动新前指向的这个节点到老节点旧前的前面            parentElm.insertBefore(oldEndVnode.elm, oldStartVnode.elm)            oldEndVnode = oldCh[--oldEndIdx]            newStartVnode = newCh[++newStartIdx]        &#125; else &#123;            // 四种命中都没有找到            // 制作keyMap，缓存            if (!keyMap) &#123;                keyMap = &#123;&#125;                    // 从 oldStartIdx 开始，到oldEndIdx结束，创建keyMap映射对象                for (let i = oldStartIdx; i <= oldEndIdx; i++) &#123;                    const key = oldCh[i].key                    if (key !== undefined) &#123;                        keyMap[key] = i                    &#125;                &#125;            &#125;            // console.log(keyMap)            // 寻找当前这项 newStartIdx 这项在 keyMap 中映射的序号            const idxInOld = keyMap[newStartVnode.key]            if (idxInOld === undefined) &#123;                // 判断，如果idxInOld是undefined 表示它是全新的项                // 被加入的项（就是newStartVnode这项）现在不是真实的DOM                parentElm.insertBefore(createElement(newStartVnode), oldStartVnode.elm)            &#125; else &#123;                // 判断，如果idxInOld不是undefined 表示它不是全新的项，需要移动                const elmToMove = oldCh[idxInOld]                patchVnode(elmToMove, newStartVnode)                    // 把这项设置为undefined，表示已经处理完了                oldCh[idxInOld] = undefined                    // 移动，调用insertBefore                parentElm.insertBefore(elmToMove.elm, oldStartVnode.elm)            &#125;            // 指针下移，只移动新的头            newStartVnode = newCh[++newStartIdx]        &#125;    &#125;    // 继续看看有没有剩余的 循环结束了 newStartIdx 还是比 newEndIdx 小    if (newStartIdx <= newEndIdx) &#123;        // new这里还有剩余节点没有处理        // 插入的标杆        // const before = newCh[newEndIdx + 1] ? newCh[newEndIdx + 1].elm : null        //        for (let i = newStartIdx; i <= newEndIdx; i++) &#123;            // insertBefore 可以自动识别 null，如果是 null 就会自动排到队尾去。和appendChild是一致的            // newCh[i] 还不是真正的DOM，所以需要此处需要调用createElement            parentElm.insertBefore(createElement(newCh[i]), oldCh[oldStartIdx].elm)        &#125;    &#125; else if (oldStartIdx <= oldEndIdx) &#123;        // old这里还有剩余节点没有处理        // 批量删除oldStartIdx~oldEndIdx之间的项        for (let i = oldStartIdx; i <= oldEndIdx; i++) &#123;            if (oldCh[i]) &#123;                parentElm.removeChild(oldCh[i].elm)            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jsonServe</title>
      <link href="/2021/120350482.html"/>
      <url>/2021/120350482.html</url>
      
        <content type="html"><![CDATA[<h1 id="jsonServe"><a href="#jsonServe" class="headerlink" title="jsonServe"></a>jsonServe</h1><p>一个简单可以提供后端接口的服务器。</p><p>_embed进行表关联  向下关联</p><p>例如请求到新闻 可以请求到新闻的相关评论</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">axios.get("http://localhost:8000/posts?_embed=comments").then(res=>&#123;    console.log(res.data)&#125;)</code></pre><p>_expand进行表关联  向上关联</p><p>例如 看到相关评论 可以向上找到具体的新闻</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">axios.get("http://localhost:8000/")</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> jsonServe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js技巧</title>
      <link href="/2021/120350482.html"/>
      <url>/2021/120350482.html</url>
      
        <content type="html"><![CDATA[<h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h3 id="递归拼接树形结构"><a href="#递归拼接树形结构" class="headerlink" title="递归拼接树形结构"></a>递归拼接树形结构</h3><p>将平级结构转为树形结构  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const rootList=[  &#123; id: 1, parent: null, text: 菜单1 &#125;,  &#123; id: 11, parent: 1, text: 菜单1-1 &#125;,  &#123; id: 111, parent: 11, text: 菜单1-1-1 &#125;,  &#123; id: 112, parent: 11, text: 菜单1-1-2 &#125;,  &#123; id: 12, parent: 1, text: 菜单1-2 &#125;,  &#123; id: 2, parent: null, text: 菜单2 &#125;,  &#123; id: 21, parent: 2, text: 菜单2-1 &#125;,  &#123; id: 22, parent: 2, text: 菜单2-2 &#125;,]function getTreeList(rootList,id,list)&#123;    //遍历整个数组让元素中parent==id的元素放入list中    for(item of rootList)&#123;        if(item.parent==id)&#123;            list.push(item)        &#125;    &#125;    for(let i of list)&#123;        i.children=[]        getTreeList(rootList,i.id,i.children)        if(i.children.length==0)&#123;            delete i.children        &#125;    &#125;    return list&#125;let test=getTreeList(rootList,null,[])</code></pre><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>节流就是让同一操作在一段时间内只发生一次，不连续发生。  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function throttle (fn)&#123;    let timer=null    return function()&#123;        if(timer)&#123;            return        &#125;        timer=setTimeout(()=>&#123;            fn()        &#125;,2000)    &#125;&#125;box.addEventListener('click',throttle(function(e)&#123;    console.log('1')&#125;))</code></pre><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> function debounce(fn)&#123;     let timer=null     return function(e)&#123;         if(timer)&#123;             clearTimeout(timer)         &#125;         timer=setTimeout(()=>&#123;             fn.apply(this.arguments)         &#125;,delay)     &#125;  &#125;input.addEventListener('input',debounce(function(event)&#123;    console.log('发送搜索请求')&#125;, 500))</code></pre><h3 id="js事件循环机制"><a href="#js事件循环机制" class="headerlink" title="js事件循环机制"></a>js事件循环机制</h3><p><img src="https://gitee.com/ycwuyang/pic-go/raw/master/img/image-20211203153415420.png" alt="image-20211203153415420"></p><p>宏任务和微任务：</p><p><img src="https://gitee.com/ycwuyang/pic-go/raw/master/img/image-20211203145240346.png" alt="image-20211203145240346"></p><p><img src="https://gitee.com/ycwuyang/pic-go/raw/master/img/image-20211203145305440.png" alt="image-20211203145305440"></p><p>script 中代码先入执行栈，在栈内先执行同步代码。如果遇到异步代码，判断是微任务还是宏任务。然后异步任务进入任务队列。当所有进入队列的微任务完成之后。一次的事件循环结束。</p><h3 id="异步操作，Promise-async"><a href="#异步操作，Promise-async" class="headerlink" title="异步操作，Promise,async"></a>异步操作，Promise,async</h3><ul><li>promise出现之前多个回调的代码：</li></ul><p>js代码分为同步代码和异步代码，在promise出现前我们要实现某一逻辑就可能出现回调函数的嵌套，这中嵌套多了就形成了回调地狱。  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var sayhello = function (name, callback) &#123;  setTimeout(function () &#123;    console.log(name);    callback();  &#125;, 1000);&#125;sayhello("first", function () &#123;  sayhello("second", function () &#123;    sayhello("third", function () &#123;      console.log("end");    &#125;);  &#125;);&#125;);//输出： first second third  end</code></pre><p>如果回调非常多的话，那么就会出现很多层回调在一起的代码。 可读性十分的差。  </p><p>为了解决这种回调地狱现象的产生，promise应运而生了。 </p><ul><li>promise出现异步编程变得简单了  </li></ul><p>promise如同它的名字一样是一个期约函数，它有三种状态。一种是pending，一种是fulfilled，还有一种是rejected。一个promise函数一开始当然是pending状态。当我们调用reslove()时，promise函数的状态就会从pending变成fulfilled 这时候会调用.then()。当我们调用rejected()时，promise函数的状态就会从pending变成rejected 这时候会调用 .catch()。当我们在.then中不抛出异常的时候，promise的状态依旧时fulfilled如果下面还有一个.then的话就会调用下一个then()。但是如果抛出异常的话，promise函数的状态就会变成rejected()  </p><p>这时候就不会执行下一个then了。.catch()也是如此。  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var test=(function()&#123;    return new Promise((reslove,reject)=>&#123;        if(false)&#123;            reslove()//此时promise变成fulfilled，调用.then()        &#125;else&#123;            reject()//此时promise变成rejected，调用.catch()        &#125;    &#125;)&#125;)()test.then(()=>&#123;    //promise变成fulfilled的时候被调用    console.log('then被调用')&#125;).catch(()=>&#123;    //promise变成rejected的时候被调用    console.log('catch被调用')&#125;).catch(()=>&#123;    console.log('catch又被调用了')&#125;)</code></pre><p>tip:christmas_tree:  这里要注意的是，如果调用reject()会先进入第一个catch(),这时候promise的状态会变成rejected，但是catch()中并没有抛出异常，这时候promise的状态就会变成fulfilled所以第二个catch()是不会执行的。  </p><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><h2 id="async-await-基础"><a href="#async-await-基础" class="headerlink" title="async/await 基础"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Async_await#asyncawait_基础">async/await 基础</a></h2><p>在代码中使用 async / await 有两个部分。</p><h3 id="async-关键字"><a href="#async-关键字" class="headerlink" title="async 关键字"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Async_await#async_关键字">async 关键字</a></h3><p>首先，我们使用 <code>async</code> 关键字，把它放在函数声明之前，使其成为 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async function</a>。异步函数是一个知道怎样使用 <code>await</code> 关键字调用异步代码的函数。</p><p>尝试在浏览器的JS控制台中键入以下行：</p><pre><code>function hello() &#123; return &quot;Hello&quot; &#125;;hello();</code></pre><p>该函数返回“Hello” —— 没什么特别的，对吧？</p><p>如果我们将其变成异步函数呢？请尝试以下方法：</p><pre><code>async function hello() &#123; return &quot;Hello&quot; &#125;;hello();</code></pre><p>哈。现在调用该函数会返回一个 promise。这是异步函数的特征之一 —— 它保证函数的返回值为 promise。</p><p>你也可以创建一个异步函数表达式（参见 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/async_function">async function expression</a> ），如下所示:</p><pre><code>let hello = async function() &#123; return &quot;Hello&quot; &#125;;hello();</code></pre><p>你可以使用箭头函数：</p><pre><code>let hello = async () =&gt; &#123; return &quot;Hello&quot; &#125;;</code></pre><p>这些都基本上是一样的。</p><p>要实际使用promise完成时返回的值，我们可以使用<code>.then()</code>块，因为它返回的是 promise：</p><pre><code>hello().then((value) =&gt; console.log(value))</code></pre><p>甚至只是简写如</p><pre><code>hello().then(console.log)</code></pre><h3 id="await关键字"><a href="#await关键字" class="headerlink" title="await关键字"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Async_await#await关键字">await关键字</a></h3><p>当 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await">await</a> 关键字与异步函数一起使用时，它的真正优势就变得明显了 —— 事实上， <strong>await 只在异步函数里面才起作用</strong>。它可以放在任何异步的，基于 promise 的函数之前。它会暂停代码在该行上，直到 promise 完成，然后返回结果值。在暂停的同时，其他正在等待执行的代码就有机会执行了。</p><p>您可以在调用任何返回Promise的函数时使用 <strong>await</strong>，包括Web API函数。</p><p>在await其实就是promise.then()的语法糖，await 关键字使JavaScript运行时暂停于此行，允许其他代码在此期间执行，直到异步函数调用返回其结果。一旦完成，您的代码将继续从下一行开始执行。</p><p><font color="red">理解：</font>我对这句话的理解就是async  和await都是微任务，在任务队列中肯定是async 在await前面，当await关键字让javaScript运行暂停于此行的时候，就会执行任务队列中下一个微任务。  </p><ul><li>当进行多个异步处理的时候，可以结合Promise.all()进行一起处理。  </li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">async function()&#123;  let coffee = fetchAndDecode('coffee.jpg', 'blob');  let tea = fetchAndDecode('tea.jpg', 'blob');  let description = fetchAndDecode('description.txt', 'text');   let [a,b,c] = await Promise.all([coffee, tea, description]);&#125;</code></pre><ul><li>当想要在循环中执行异步，可以使用for await (let result of promises){}  这里的for循环依然会等到所有的异步操作都完成之后才继续向后执行。</li></ul><h3 id="ES6-ES11"><a href="#ES6-ES11" class="headerlink" title="ES6-ES11"></a>ES6-ES11</h3><ul><li><p>函数参数的默认值设置：</p><p> ```javascript<br> //1.在es6可以给函数的参数设置初始值<br> function add(a,b,c=10){</p><pre><code> return a+b+c</code></pre><p> }</p><p> let result =add(1,2)//这里c默认就是10</p><p> //2. 与结构赋值一起使用<br> let option ={</p><pre><code> name:&#39;&#39;, age:18, sex:&#39;男&#39;</code></pre><p> }</p></li></ul><p>   function connect({name=”吴洋”,age,sex}){<br>       console.log(name)<br>       console.log(age)<br>       console.log(sex)<br>   }</p><p>   connect(option)</p><pre><code>-  rest参数  rest参数必须要放到参数最后  ```javascript  function fn(a,b,...args)&#123;      console.log(a)      console.log(b)      console.log(args)  &#125;  fn(1,2,3,4,5,6)  //a是1，b是2，args是3，4，5，6 而且args是一个数组</code></pre><ul><li><p>拓展运算符…</p><p>能将[数组]转化为逗号分割的[参数序列] </p><p>扩展运算符的应用：</p><ul><li>扩展运算符进行数组合并  </li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">       const test1 = ['测试1', '测试2']       const test2 = ['测试3', '测试4']       const zuhe = [...test1, ...test2]       console.log(zuhe);//(4) ['测试1', '测试2', '测试3', '测试4']</code></pre><ul><li>扩展运算符进行数组的克隆  </li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">          const test1 = ['测试1', '测试2']         const zuhe = [...test1]       console.log(zuhe);//2) ['测试1', '测试2']</code></pre><ul><li>扩展运算符可以进行对象的合并  </li></ul><p>如果两个对象中又共有的属性时，如果扩展在共有属性上面那么此时的共有属性将展示被扩展对象的值，如果在共有属性下面则展示扩展过去对象的值</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">        const test2 = &#123;           name: "步之",           age: 18       &#125;       const test1 = &#123;           name: "吴洋",           sex: "男",           ...test2       &#125;       console.log(test1);//&#123;name: '步之', sex: '男', age: 18&#125;</code></pre></li><li><p>Symbol基本使用   给对象设置独一无二的属性和值</p><ul><li><p>1.Symbol 的值是唯一的，用来解决命名冲突的问题  </p><p>2.Symbol 值不能与其他数据进行运算  </p><p>3 Symbol 定义的对象属性不能使用for in 循环遍历，但是可以使用Reflect.ownKeys来获取</p><p>对象的所有键名  </p></li><li><p>创建Symbol  </p></li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">          //创建Symbol       let s = Symbol('吴洋')       let s1 = Symbol('吴洋')       console.log(s == s1);//false       //创建Symbol       let s2 = Symbol.for('吴洋')       let s3 = Symbol.for('吴洋')       console.log(s2 == s3);//true</code></pre></li><li><p>迭代器  </p><p>在 JavaScript 中，<strong>迭代器</strong>是一个对象，它定义一个序列，并在终止时可能返回一个返回值。 更具体地说，迭代器是通过使用 <code>next()</code> 方法实现 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol">Iterator protocol</a> 的任何一个对象，该方法返回具有两个属性的对象： <code>value</code>，这是序列中的 next 值；和 <code>done</code> ，如果已经迭代到序列中的最后一个值，则它为 <code>true</code> 。如果 <code>value</code> 和 <code>done</code> 一起存在，则它是迭代器的返回值。</p><ul><li><p>工作原理：</p><p>a) 创建一个指针对象，指向当前数据结构的起始位置</p><p>b) 第一次调用对象的next 方法，指针自动指向数据结构的第一个成员</p><p>c) 接下来不断调用next方法，指针一直往后移动，直到指向最后一个成员</p><p>d) 每调用next 方法返回一个包含value和done 属性的对象</p></li><li><p>自定义迭代器  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">  const test = &#123;           name: "111",           testArr: [               '吴洋',               '666',               '777'           ],           [Symbol.iterator]() &#123;               let index = 0               let _this = this               return &#123;                   next: function() &#123;                       if (index < _this.testArr.length) &#123;                           const result = &#123;                                   value: _this.testArr[index],                                   done: false                               &#125;                               //下标自增                           index++                           return result                       &#125; else &#123;                           return &#123;                               value: undefined,                               done: true                           &#125;                       &#125;                   &#125;               &#125;           &#125;       &#125;       for (let v of test) &#123;           console.log(v);       &#125;</code></pre></li></ul></li><li><p>生成器  </p><p> 虽然自定义的迭代器是一个有用的工具，但由于需要显式地维护其内部状态，因此需要谨慎地创建。生成器函数提供了一个强大的选择：它允许你定义一个包含自有迭代算法的函数， 同时它可以自动维护自己的状态。 生成器函数使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*"><code>function*</code></a>语法编写。 最初调用时，生成器函数不执行任何代码，而是返回一种称为Generator的迭代器。 通过调用生成器的下一个方法消耗值时，Generator函数将执行，直到遇到yield关键字。</p></li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">   function* gen() &#123;            yield &#123;                name: '666',                testArr: ['数组']            &#125;            yield '不知道'            yield 'niiiii'        &#125;        let it = gen()        console.log(it.next());//&#123;value:&#123;name:'666',testArr:['数组']&#125;,done:false&#125;        console.log(it.next());//&#123;value:'不知道',done:false&#125;        console.log(it.next());//&#123;value:'niiiii',done:falsse&#125;            console.log(it.next());//&#123;value:undefined,done:true&#125;</code></pre><p> 生成器传参：</p><p>第一个yield接收第二个next函数传递过来的参数。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">  function* gen() &#123;            let d = yield &#123;                name: '666',                testArr: ['数组']            &#125;            console.log(d);//bbb            yield '不知道'            yield 'niiiii'        &#125;        let it = gen()        console.log(it.next('aaa'));        console.log(it.next('bbb'));</code></pre><ul><li><p>set集合  </p><p>类似于数组， 但成员的值都是唯一的，集合实现了iterator接口，所以可以使用扩展运算符和for of 进行遍历。  </p><ul><li><p>常用方法  </p><p>size,add,delete,clear,has</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">     let set1 = new Set(['1', '2', '3'])       console.log(set1);       console.log(set1.size);       set1.add('4')       console.log(set1);       set1.delete('1')       console.log(set1);       // set1.clear()       // console.log(set1);       for (const iterator of set1) &#123;           console.log(iterator);       &#125;</code></pre></li><li><p>应用  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">      let arr = [1, 2, 3, 4, 5, 6, 6, 3, 2]          //数组去重          // let arr1 = [...new Set(arr)]          // console.log(arr1);      //取交集      let arr2 = [1, 2, 3, 3, 2, 1]      let res = [...new Set(arr)].filter(item => new Set(arr2).has(item))      console.log(res);      //取并集      let union = [...new Set([...arr, ...arr2])]      console.log(union);      //差集      let diff = [...new Set(arr)].filter(item => !(new Set(arr2).has(item)))      console.log(diff);</code></pre></li></ul></li><li><p>Map 集合  </p><p>类似于对象，也是键值对的集合，但是”键“ 的范围不限于字符串，各种类型的值(包括对象)都可以  </p><p>当作键，Map也可以实现迭代，所以可以使用[扩展运算符]和for of 进行遍历。</p><ul><li><p>map 的属性和方法  </p><ul><li><p>size  返回Map的元素个数  </p></li><li><p>set  增加一个新元素，返回当前Map  </p></li><li><p>get 返回键名对象的键值</p></li><li><p>has 检测Map中是否包含某个元素，返回boolean值</p></li><li><p>clear 清空集合 返回undefined</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> let school = &#123;               name: 'de',               age: 222           &#125;           // console.log(Object.entries(school))       let m = new Map(Object.entries(school))       m.set('name', 'newName')//可以根据key修改值，也可以创建       console.log(m.get('name'));//获取</code></pre></li></ul></li></ul></li></ul><ul><li><p>class的使用  </p><p>基本使用：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">  class phone &#123;            constructor(name, price) &#123;                this.name = name                this.price = price            &#125;            call() &#123;                console.log('我可以打电话');            &#125;        &#125;        let newPhone = new phone('111', '222')        console.log(newPhone);        newPhone.call()</code></pre><p>继承</p><p>```javascript</p><pre><code>class phone &#123;        constructor(name, price) &#123;            this.name = name            this.price = price        &#125;        call() &#123;            console.log(&#39;打我电话&#39;);        &#125;    &#125;</code></pre></li></ul><pre><code>      class smallphone extends phone &#123;          constructor(name, price, color) &#123;              super(name, price)              this.color = color          &#125;          play() &#123;              console.log(this.name);          &#125;      &#125;      var r = new phone(&#39;小红&#39;, 1111)      var s = new smallphone(&#39;小幂&#39;, 1999, &#39;黑色&#39;)      s.call()      s.play()</code></pre><pre><code>    get和set的使用：   ```javascript   class Phone&#123;       get price()&#123;           console.log(&#39;get&#39;)           return &#39;111&#39;       &#125;       set price(newVal)&#123;           console.log(&#39;set&#39;)       &#125;   &#125;   let s=new Phone    s.price    s.price=&#39;free&#39;</code></pre><ul><li><p>对象方法的扩展 </p><ul><li><p>1.Object.is 判断两个值是否完全相等</p></li><li><p>2.Object.assign  对象的合并 </p></li><li><p>Object.entries 返回一个给定对象自身可遍历属性[key,value]的数组,多用于创建Map集合</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">  let school = &#123;               name: 'de',               age: 222           &#125;       console.log(Object.entries(school))//(2) [Array(2), Array(2)]0: (2) ['name', 'de']1: (2) ['age', 222]length: 2[[Prototype]]: Array(0)       let m = new Map(Object.entries(school))       console.log(m);//Map(2) &#123;'name' => 'de', 'age' => 222&#125;[[Entries]]0: &#123;"name" => "de"&#125;1: &#123;"age" => 222&#125;size: 2[[Prototype]]: Map</code></pre></li><li><p>Object.fromEntries 将二维数组转换为对象</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const result=Object.fromEntries([['age','18']['name','尚硅谷']    ])console.log(result)//键值对形式</code></pre></li></ul></li><li><p>字符串方法的扩展</p><ul><li><p>trimStart与trimEnd</p><p>trimStart清除左侧字符串空白，trimEnd清除右侧字符串空白</p></li></ul></li></ul><ul><li><p>数组方法的扩展  </p><ul><li><p>flat 将多维数组转化为低维数组,可以传入一个参数，这个参数表示的是深度，比如三维数组转为一维数组传入的是2</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> let a = [1, 2, 3, [1, 2, 3]]       console.log(a.flat())//(6) [1, 2, 3, 1, 2, 3]</code></pre></li></ul></li></ul><ul><li><p>flatMap 结合了Map和flat</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let a = [1, 2, 3, 4]        const result = a.flatMap(item => [item * 10])        console.log(result);//(4) [10, 20, 30, 40]</code></pre></li></ul><ul><li><p>class中私有属性</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">  class Person &#123;            //公有属性            name = 'test'               //私有属性            #age = 0            constructor(name, age) &#123;                this.name = name                this.#age = age            &#125;            test() &#123;                console.log(this.#age);            &#125;        &#125;        let p = new Person('1', 11)        // console.log(p.#age);在class外部调用私有属性会报错</code></pre></li><li><p>可选链操作符</p><p>?.  在函数传参时，如果有就使用如果没有就undefined</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function test(info1)&#123;     const testInfo=info1?.info?.name     console.log(testInfo);   &#125;   test(&#123;     info:&#123;       // name:"wy"     &#125;   &#125;)//传统写法function test(info1)&#123;   const testInfo=info1.info.name&#125;//但是如果这里不进行传值的话，就会报错test()</code></pre></li></ul><ul><li><p>动态import</p><p>import()函数 是一个promise对象</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">import('./hello.js').then(module=>&#123;    module.hello()&#125;)</code></pre></li></ul><ul><li>globalThis 始终指向全局对象</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javasript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React</title>
      <link href="/2021/120350482.html"/>
      <url>/2021/120350482.html</url>
      
        <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h3 id="jsx-："><a href="#jsx-：" class="headerlink" title="jsx ："></a>jsx ：</h3><p>jsx语法规则：<br>1.定义虚拟dom时，不需要写引号<br>2.标签中混入js表达式时要用花括号<br>3.样式得类名不要使用class要用className<br>4.内联样式，要用style=双花括号的形式<br>5.虚拟dom必须只有一个根标签<br>6.标签必须闭合<br>7.标签首字母<br>(1).若小写字母开头，则将该标签转换为html中同名元素，若html中无该标签对应的同名元素则报错<br>(2). 若大写字母开头，react就去渲染对应的组件，若组件没有定义就会报错 </p><h3 id="react中循环遍历渲染数据："><a href="#react中循环遍历渲染数据：" class="headerlink" title="react中循环遍历渲染数据："></a>react中循环遍历渲染数据：</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript"><!-- 此处一定要写babel，因为此时写的时jsx -->  <script type="text/babel">    //1.创建虚拟dom    const data=['test1','test2','test3']    const VDOM=(      <div>        <ul>          &#123;            data.map((item,index)=>&#123;              return <li key=&#123;index&#125;>&#123;item&#125;</li>            &#125;)          &#125;          </ul>        </div>    )    //2.渲染虚拟dom到页面    ReactDOM.render(VDOM,document.getElementById('test'))  </script></code></pre><h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><ul><li><p>执行了ReactDOM.render(<MyComponent>…..之后发生了</MyComponent></p><p>1.React解析组件标签，找到了MyComponent组件</p><p>2.发现组件时使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM</p></li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">  //创建函数式组件    function MyComponent()&#123;      return <h2>测试</h2>    &#125;    ReactDOM.render(<MyComponent/>,document.getElementById('test'))</code></pre><h3 id="类式组件"><a href="#类式组件" class="headerlink" title="类式组件"></a>类式组件</h3><ul><li><p>执行了ReactDOM.render(<MyComponent>…..之后发生了</MyComponent></p><p>​    1.React解析组件标签，找到了MyComponent组件</p><p>​    2.发现组件是类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法。</p><p>​    3.将返回的虚拟DOM转为真实DOM</p><ul><li>render是放在哪里的？——MyComponent的原型对象上，供实例使用</li><li>render中的this是谁？———MyComponent 的实例对象</li></ul></li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript"> //创建类式组件    class MyComponent extends React.Component&#123;      render()&#123;        return <h2>测试</h2>      &#125;    &#125;    ReactDOM.render(<MyComponent/>,document.getElementById('test'))</code></pre><h3 id="组件实例的三大核心属性state"><a href="#组件实例的三大核心属性state" class="headerlink" title="组件实例的三大核心属性state"></a>组件实例的三大核心属性state</h3><p>实例中有state属性</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">    class MyComponent extends React.Component&#123;      constructor(props)&#123;        super(props)           &#125;      state=&#123;          isHot:false        &#125;      render()&#123;        return <h2 onClick=&#123;this.demo&#125;>今天天气真&#123;this.state.isHot?'炎热':'凉凉'&#125;</h2>      &#125;       demo=()=>&#123;        const isHot=this.state.isHot        this.setState(&#123;isHot:!isHot&#125;,()=>&#123;            //这里可以加一个回调        &#125;)    &#125;    &#125;    ReactDOM.render(<MyComponent/>,document.getElementById('test'))</code></pre><ul><li>组件中的render方法中的this 为组件实例对象</li><li>组件中自定义的方法中this为undefined，可以使用箭头函数</li><li>使用setState直接设置状态机，如果状态机中没有此状态就创建一个新的。但是一般需要进行状态的初始化</li></ul><p>setState的第二种写法：</p><p>因为setState是一个异步任务，在修改后不会立马显示。所以在setState中有一个回调</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//函数式的setStatethis.setState((state,props)=>&#123;    return &#123;count:state.count+1 &#125;&#125;)</code></pre><h3 id="组件中三大属性props"><a href="#组件中三大属性props" class="headerlink" title="组件中三大属性props"></a>组件中三大属性props</h3><p>批量转入props</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">  class Person extends React.Component&#123;      render()&#123;        console.log(this);        return <ul>          <li>&#123;this.props.name&#125;</li>          <li>&#123;this.props.age&#125;</li>        </ul>      &#125;    &#125;    const p=&#123;      name:'wy',      age:12    &#125;     ReactDOM.render(<Person &#123;...p&#125;/>,document.getElementById('test'))</code></pre><p>对props的传入进行限制  </p><p> 需要先引入依赖包 </p><pre class=" language-lang-javascript"><code class="language-lang-javascript"><script src="../js/prop-types.js"></script></code></pre><pre class=" language-lang-javascript"><code class="language-lang-javascript">   class Person extends React.Component&#123;      render()&#123;       this.props.speak()        return <ul>          <li>&#123;this.props.name&#125;</li>          <li></li>        </ul>      &#125;    &#125;//对传入props进行限制，tip：注意大小写  函数限制要写成func    Person.propTypes=&#123;      name:PropTypes.string.isRequired,      speak:PropTypes.func    &#125;    Person.defaultProps=&#123;      name:'吴洋'    &#125;    function speak()&#123;      console.log(1);    &#125;    ReactDOM.render(<Person speak=&#123;speak&#125;/>,document.getElementById('test'))</code></pre><p>tip：在props中传入数值时要这样传{10}，不可以直接=10，这样会报错。</p><p>简写：(最终写法)</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> class Person extends React.Component&#123;     //限制    static  propTypes=&#123;      name:PropTypes.string.isRequired,      speak:PropTypes.func    &#125;    //默认值    static  defaultProps=&#123;      name:'吴洋'    &#125;      render()&#123;       this.props.speak()        return <ul>          <li>&#123;this.props.name&#125;</li>          <li>&#123;this.props.age&#125;</li>        </ul>      &#125;    &#125;    function speak()&#123;      console.log(1);    &#125;    ReactDOM.render(<Person speak=&#123;speak&#125; age=&#123;19&#125;/>,document.getElementById('test'))</code></pre><h3 id="组件三大属性Ref"><a href="#组件三大属性Ref" class="headerlink" title="组件三大属性Ref"></a>组件三大属性Ref</h3><ul><li>字符串形式的ref（过时）</li></ul><p>和vue的ref一样可以拿到dom元素</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> class Demo extends React.Component&#123;      showData=()=>&#123;        const &#123;input1&#125;=this.refs        alert(input1.value )      &#125;      render()&#123;        return (          <div>            <input ref="input1" type="text" placeholder="点击按钮提示数据"/>&nbsp;            <button onClick=&#123;this.showData&#125;>点我提示左侧的数据</button>&nbsp;            <input type="text" placeholder="失去焦点提示数据"/>            </div>        )      &#125;    &#125;    ReactDOM.render(<Demo/>,document.getElementById('test'))</code></pre><ul><li>回调形式的ref</li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">    class Demo extends React.Component&#123;      showData=()=>&#123;        const &#123;input1&#125;=this        alert(input1.value )      &#125;      render()&#123;        return (          <div>            <input ref=&#123;(a)=>&#123;this.input1=a&#125;&#125; type="text" placeholder="点击按钮提示数据"/>&nbsp;            <button onClick=&#123;this.showData&#125;>点我提示左侧的数据</button>&nbsp;            <input type="text" placeholder="失去焦点提示数据"/>            </div>        )      &#125;    &#125;    ReactDOM.render(<Demo/>,document.getElementById('test'))</code></pre><ul><li><p>createRef的使用</p><p>React。createRef 调用后返回一个容器，该容器可以存储被ref 所标识的节点，该容器是专人专用的。 如果下面继续使用 后面的ref将代替前面的ref。</p><p>要使用几个dom 的ref 就要创建几个容器</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> class Demo extends React.Component&#123;      myRef=React.createRef()      show=()=>&#123;        console.log(this.myRef.current);      &#125;      render()&#123;        return(          <div>            <div ref=&#123;this.myRef&#125;>11</div>            <button onClick=&#123;this.show&#125;>按钮</button>            </div>        )      &#125;    &#125;    ReactDOM.render(<Demo/>,document.getElementById('test'))</code></pre></li></ul><ul><li><p>事件处理 </p><p>一：通过onXxx属性指定事件处理函数(注意大小写)</p><p>1) React使用的是自定义(合成)事件, 而不是使用的原生DOM事件</p><p>2) React中的事件是通过事件委托方式处理的(委托给组件最外层的元素)</p><p>二：通过event.target得到发生事件的DOM元素对象  (当发生事件的元素正好是要操作的元素时，不需要写ref 可以直接用event.target直接拿到)</p></li></ul><ul><li><p>收集表单数据</p><ul><li><p>非受控组件：</p><p>现用现取</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> //创建组件    class Login extends React.Component&#123;      handleSubmit=()=>&#123;        const &#123;password,username&#125;=this        alert(username.value)      &#125;      render()&#123;        return (          <form action="http://www.atguigu.com" onSubmit=&#123;this.handleSubmit&#125;>           用户名： <input ref=&#123; c=>this.username=c&#125; type="text"/>           密码：   <input ref=&#123; c=>this.password=c&#125;type="password"/>           <button>登录</button>            </form>        )      &#125;    &#125;    //渲染组件    ReactDOM.render(<Login/>,document.getElementById('test'))</code></pre></li></ul></li></ul><ul><li><p>受控组件：</p><p>不用写ref  与vue中的双向数据绑定有点相似</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">    //创建组件    class  Login extends React.Component&#123;      state=&#123;        username:'',        password:''      &#125;      saveUsername=(event)=>&#123;        this.setState(&#123;username:event.target.value&#125;)      &#125;      savePassword=(event)=>&#123;        this.setState(&#123;password:event.target.value&#125;)      &#125;      handleSubmit=(event)=>&#123;        event.preventDefault()//阻止默认事件        const &#123;username,password&#125;=this.state        alert(`您输入用户名是$&#123;username&#125;,您输入密码是$&#123;password&#125;`)      &#125;      render()&#123;        return (          <form onSubmit=&#123;this.handleSubmit&#125;>          用户名：<input type="text" onChange=&#123;this.saveUsername&#125;/>           密码： <input type="password" onChange=&#123;this.savePassword&#125;/>           <button>登录</button>            </form>        )      &#125;    &#125;    ReactDOM.render(<Login/>,document.getElementById('test'))</code></pre></li></ul><p>  函数柯里化写出非控组件</p><p>  函数的柯里化就是在函数下面再次return 出去函数。使用于不可以一次性接收参数。</p><p>  比如说一些钩子函数，这里React中已经传入了一个event不可以传入两个参数产生冲突，所以就需要使用函数的柯里化。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">   saveFormData=(dataType)=>&#123;          return (event)=>&#123;            this.setState(&#123;[dataType]:event.target.value&#125;)          &#125;        &#125;</code></pre><pre class=" language-lang-javascript"><code class="language-lang-javascript">   //创建组件      class  Login extends React.Component&#123;        state=&#123;          username:'',          password:''        &#125;        saveFormData=(dataType)=>&#123;          return (event)=>&#123;            this.setState(&#123;[dataType]:event.target.value&#125;)          &#125;        &#125;        handleSubmit=(event)=>&#123;          event.preventDefault()//阻止默认事件          const &#123;username,password&#125;=this.state          alert(`您输入用户名是$&#123;username&#125;,您输入密码是$&#123;password&#125;`)        &#125;        render()&#123;          return (            <form onSubmit=&#123;this.handleSubmit&#125;>              //这里onChange调用的不是saveFormData这个函数而是这个函数的返回值            用户名：<input type="text" onChange=&#123;this.saveFormData('username')&#125;/>             密码： <input type="password" onChange=&#123;this.saveFormData('password')&#125;/>             <button>登录</button>              </form>          )        &#125;      &#125;      ReactDOM.render(<Login/>,document.getElementById('test'))</code></pre><h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><p><img src="/2021/Users\0\AppData\Roaming\Typora\typora-user-images\image-20220208192741699.png" alt="image-20220208192741699"></p><p>当调用setState更新状态的时候，</p><p> 1.调用是否允许更新的钩子(shouldComponentUpdate) 返回的是一个布尔值(true 继续向下执行,false 中断执行) </p><p> 2.调用componentWillUpdate</p><p> 3.调用render()钩子 进行渲染</p><p> 4.调用componentDidUpdate  这里可以有两个参数  一个是之前的Props 一个是之前的State</p><p><img src="/2021/Users\0\AppData\Roaming\Typora\typora-user-images\image-20220209103825574.png" alt="image-20220209103825574"></p><p>当调用forceUpdate更新状态的时候是强制进行更新</p><p><img src="/2021/Users\0\AppData\Roaming\Typora\typora-user-images\image-20220208211141206.png" alt="image-20220208211141206"></p><ul><li><p>新组件的生命周期</p><p><img src="/2021/Users\0\AppData\Roaming\Typora\typora-user-images\image-20220209094607796.png" alt="image-20220209094607796"></p></li><li><p>新版本废弃了componentWillMount和componentWillReceiveProps和componentWillUpdate这三个钩子。提出getDeriveStateFromProps和getSnapshotBeforeUpdate这两个新钩子</p></li><li><p>getDeriveStateFromProps</p><p>可以return null 和状态对象</p><p>return 出去的这个props可以直接覆盖掉state中的状态。 而且不可以进行更新。当state中的值取决于props 时可以使用</p><p><img src="/2021/Users\0\AppData\Roaming\Typora\typora-user-images\image-20220209102300162.png" alt="image-20220209102300162"></p></li><li><p>getSnapshotBeforeUpdate</p><p>return null 和快照</p></li></ul><h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h3><p><img src="/2021/Users\0\AppData\Roaming\Typora\typora-user-images\image-20220209115035234.png" alt="image-20220209115035234"></p><h3 id="react脚手架"><a href="#react脚手架" class="headerlink" title="react脚手架"></a>react脚手架</h3><p>  create-react-app todolist 创造项目</p><h3 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h3><p>父组件传子组件 使用props </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//父组件中<Son name=&#123;name&#125;/>//子组件中 const &#123;name&#125;=this.props</code></pre><p>子组件传父组件使用props传函数</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//父组件中name=(data)=>&#123;&#125;<Son name=&#123;this.name&#125;/>//子组件中 this.props.name(传入的数据)</code></pre><h3 id="脚手架配置代理"><a href="#脚手架配置代理" class="headerlink" title="脚手架配置代理"></a>脚手架配置代理</h3><ul><li>配置一个代理</li></ul><p>配置package.json 在最后加上服务器的地址</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> "proxy": "http://localhost:5000"</code></pre><ul><li><p>配置多个代理</p><p>1.新键setupProxy.js文件</p><p>这个写法和vue 中的差不多  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const &#123;createProxyMiddleware&#125;=require('http-proxy-middleware')module.exports=function (app)&#123;    app.use(   '/api',   createProxyMiddleware(&#123;     target:'http://localhost:5000',     changeOrigin:true,   &#125;)  )&#125;</code></pre></li></ul><h3 id="消息发布与订阅"><a href="#消息发布与订阅" class="headerlink" title="消息发布与订阅"></a>消息发布与订阅</h3><p>功能：用于兄弟组件之间的通信</p><p>下载 cnpm i pubsub-js这个js库</p><p>传出组件中发布消息， 传入组件中订阅消息</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//一般在componentDidMount组件初始化的时候接收组件通信的数据componentDidMount() &#123;    //订阅消息    PubSub.subscribe('atguigui', (msg, data) => &#123;      this.setState(data)    &#125;)  &#125;</code></pre><pre class=" language-lang-javascript"><code class="language-lang-javascript">//发布消息  PubSub.publish('atguigui', &#123; isFirst: false, isLoading: true &#125;)</code></pre><h3 id="路由的基本使用"><a href="#路由的基本使用" class="headerlink" title="路由的基本使用"></a>路由的基本使用</h3><p> 安装 5版本 cnpm i react-router-dom@5.2.0</p><p>5版本中的用法：</p><p>先用<BrowserRouter><BrowserRouter>包裹住所有组件放置的App</BrowserRouter></BrowserRouter></p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> <BrowserRouter>    <App /> </BrowserRouter></code></pre><p>链接标签的使用：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">   <Link className='list-group-item' to="/about">About</Link>   <Link className='list-group-item' to="/home">Home</Link></code></pre><p>注册路由：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">    <Route path="/about" component=&#123;About&#125;/>    <Route path="/home" component=&#123;Home&#125;/></code></pre><ul><li><p>NavLink的使用  </p><p>当你点击NavLInk的时候会自动添加一个类名 </p><p>可以设置avtiveClassName 当点击这个路由链接的时候就添加这个类名</p><p>NavLink 默认添加的类名是active</p></li></ul><ul><li><p>switch 的使用</p><p>在注册路由的外边包裹一层switch 之后匹配到路由组件之后就不会向下进行匹配了。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">  <Switch>               <Route path="/about" component=&#123;About&#125;/>               <Route path="/home" component=&#123;Home&#125;/>  </Switch></code></pre></li></ul><ul><li><p>解决样式冲突的问题</p><p>当路由是多级路由时，并且刷新之后样式会丢失</p><p>解决方案：</p><p>使用绝对路径</p></li></ul><ul><li><p>路由的模糊匹配与精准匹配</p><p>默认开启的是模糊匹配</p><p>exact={true}  开启精准匹配</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"><Route exact=&#123;true&#125; path="/about" component=&#123;About&#125;/><Route exact=&#123;true&#125; path="/home" component=&#123;Home&#125;/></code></pre></li></ul><ul><li><p>Redirect的使用</p><p>重定向，如果什么都没有匹配到的情况下最后就去到Redirect 指向的路径</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"><Route exact=&#123;true&#125; path="/about" component=&#123;About&#125;/><Route exact=&#123;true&#125; path="/home" component=&#123;Home&#125;/><Redirect to="/about"/></code></pre></li></ul><ul><li><p>嵌套路由</p><p>嵌套路由下面要加上一级路由的名字，而且一级路由不要开启精准匹配</p></li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript"> <li>     <NavLink to="/home/news">News</NavLink>  </li>  <li>      <NavLink to="/home/message">Message</NavLink>  </li></code></pre><ul><li><p>向路由组件传递params参数</p><p>在路由链接上传入进去需要传递的参数</p></li></ul><p>这里传递过去的是id，和title</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">  <Link to=&#123;`/home/message/detail/$&#123;item.id&#125;/$&#123;item.title&#125;`&#125;>&#123;item.title&#125;</Link></code></pre><p>在声明路由的地方标注需要传递的参数</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">  <Route path="/home/message/detail/:id/:title" component=&#123;Detail&#125; /></code></pre><p>在路由组件中使用传递过来的参数</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">  const &#123; id, title &#125; = this.props.match.params</code></pre><ul><li><p>向路由组件传递search参数</p><p>1.在路由链接上传入进去需要传递的参数</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">  &#123;/* 向路由组件传递search 参数 */&#125;<Link to=&#123;`/home/message/detail/?id=$&#123;item.id&#125;&title=$&#123;item.title&#125;`&#125;>&#123;item.title&#125;</Link></code></pre><p>2.search 在声明路由的时候不需要进行标注</p><p>3.接收参数的时候需要引入qs进行字符串的处理</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> const &#123; search &#125; = this.props.location const &#123; id, title &#125; = qs.parse(search.slice(1))</code></pre></li></ul><ul><li><p>向路由组件传递state参数</p><p>在地址栏上不显示传递的参数,刷新后参数不会丢失</p><p>1.在路由链接上传入进入需要传递的参数</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> <Link to=&#123;&#123; pathname: '/home/message/detail', state: &#123; id: item.id, title: item.title &#125; &#125;&#125;>&#123;item.title&#125;</Link></code></pre><p>2.state 参数在声明路由的时候不需要进行标注</p><p>3.接收参数</p><p>如果没有传递的话默认就为空对象</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const &#123; id, title &#125; = this.props.location.state || &#123;&#125;</code></pre></li></ul><ul><li><p>编程式路由导航</p><p>1.push 跳转  带有历史浏览记录</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">this.props.history.push(`/home/message/detail/$&#123;id&#125;/$&#123;title&#125;`)</code></pre><p>2.replace跳转</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">this.props.history.replace(`/home/message/detail/$&#123;id&#125;/$&#123;title&#125;`)</code></pre></li></ul><p><img src="/2021/Users\0\AppData\Roaming\Typora\typora-user-images\image-20220221164119900.png" alt="image-20220221164119900"></p><p>编程式前进</p><p>this.props.history.goForward()</p><p>编程式后退</p><p>this.props.history.goBack()</p><p>编程式定位</p><p>this.props.history.go(前进或者后退的页数)  负数是后退</p><ul><li><p>withRouter的使用</p><p>withRouter 可以加工一般组件变为路由组件。为一般组件加上路由得api</p></li></ul><h3 id="antd-UI组件库的使用"><a href="#antd-UI组件库的使用" class="headerlink" title="antd UI组件库的使用"></a>antd UI组件库的使用</h3><p>ant-design 国内蚂蚁金服</p><p>1.<a href="https://ant.design/index-cn">https://ant.design/index-cn</a></p><h3 id="redux状态管理"><a href="#redux状态管理" class="headerlink" title="redux状态管理"></a>redux状态管理</h3><p><img src="/2021/Users\0\AppData\Roaming\Typora\typora-user-images\image-20220224113447322.png" alt="image-20220224113447322"></p><ul><li><p>redux 精简版基本使用</p><ol><li><p>先创建store.js 文件</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//引入createStore，专门用于创建redux 中最为核心的store对象import &#123; createStore &#125; from 'redux'//引入为Count 组件服务的reducerimport countReducer from './count_reducer'export default createStore(countReducer)</code></pre></li><li><p>创建专门为需要进行状态管理的组件的js文件</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">/* 1.该文件是用于创建一个为Count组件服务的reducer，reducer 本身就是一个函数  2.reducer函数会接收到两个参数，分别是之前的状态和动作对象*/const initState=0export default function count_reducer ( pre=initState,aciton)&#123;  const &#123;type,data&#125;=aciton  switch (type) &#123;    case 'increment':     return  pre+data     case 'decrement':       return  pre-data    default:      return pre  &#125;&#125;</code></pre></li><li><p>在组件中使用 store.getState()获取状态</p><p>使用store.dispath() 进行状态的更改</p><p>因为状态更改后不会自己更新组件 需要调用store.subscribe()去更新视图</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">import React, &#123; Component &#125; from 'react'//引入storeimport store from '../redux/store'export default class Count extends Component &#123; componentDidMount() &#123;   //检测redux中状态的变化，只要变化就调用render  ！重要   store.subscribe(() => &#123;     this.setState(&#123;&#125;)   &#125;) &#125; increment = () => &#123;   const &#123; value &#125; = this.selectNumber   // const &#123; count &#125; = this.state   // this.setState(&#123; count: count + value * 1 &#125;)   store.dispatch(&#123; type: 'increment', data: value * 1 &#125;) &#125; decrement = () => &#123;   const &#123; value &#125; = this.selectNumber   store.dispatch(&#123; type: 'decrement', data: value * 1 &#125;) &#125; incrementIfOdd = () => &#123; &#125; incrementAsync = () => &#123; &#125; render() &#123;   return (     <div>       <h1>当前求和为：&#123;store.getState()&#125;</h1>       <select ref=&#123;c => this.selectNumber = c&#125;>         <option value="1">1</option>         <option value="2">2</option>         <option value="3">3</option>       </select>       <button onClick=&#123;this.increment&#125;>+</button>       <button onClick=&#123;this.decrement&#125;>-</button>       <button onClick=&#123;this.incrementIfOdd&#125;>当前求和为奇数再加</button>       <button onClick=&#123;this.incrementAsync&#125;>异步加</button>     </div>   ) &#125;&#125;</code></pre></li></ol></li></ul><ul><li><p>完整版的Redux</p><p>比精简版的多了命名文件 和aciton文件</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">/* 该模块是用于定义aciton 对象中type 类型的常量值 */export const INCREMENT='increment'export const DECREMENT='decrement'</code></pre></li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">/* 该文件专门为Count组件生成action对象 */import store from '../redux/store'import &#123;INCREMENT,DECREMENT&#125; from './constant'export  function createIncrementAction(data)&#123;    return &#123;      type:INCREMENT,      data    &#125;&#125;//同步aciton 返回值是一个对象export  function createDecrementAction(data)&#123;  return &#123;    type:DECREMENT,    data  &#125;&#125;</code></pre><ul><li><p>异步的Redux</p><p>返回的aciton 是一个函数</p><p>还需要下载 cnpm i redux-thunk</p><p>在store文件中使用</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//引入createStore，专门用于创建redux 中最为核心的store对象import &#123; createStore,applyMiddleware &#125; from 'redux'//引入为Count 组件服务的reducerimport countReducer from './count_reducer'//引入redux-thunk 开启异步import thunk from 'redux-thunk'export default createStore(countReducer,applyMiddleware(thunk))</code></pre></li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">  //所谓的异步action 就是值aciton 的值为函数  export const createIncrementAsyncAciton =(data,time)=>&#123;    console.log(1);    return ()=>&#123;      setTimeout(()=>&#123;        store.dispatch(createIncrementAction(data))      &#125;,time)    &#125;  &#125;</code></pre><ul><li>react-redux 模型图</li></ul><p><img src="/2021/Users\0\AppData\Roaming\Typora\typora-user-images\image-20220225120743403.png" alt="image-20220225120743403"></p><p>基本使用方法：</p><p>思路：创建Count容器放置在App中。 在Count容器中引入Count的ui组件。用connect将count和redux连接起来</p><p>函数返回的对象中的key就座位传递给UI组件props的key value就座位传递给UI组件中的value-传递状态</p><p>在APP.jsx中使用Count 容器的时候 要给容器传入store</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">import React, &#123; Component &#125; from 'react'import Count from './containers/Count'import store from './component/redux/store'export default class App extends Component &#123;  render() &#123;    return (      <div>        <Count store=&#123;store&#125; />      </div>    )  &#125;&#125;</code></pre><pre class=" language-lang-javascript"><code class="language-lang-javascript">//引入Count的UI组件import CountUI from '../../component/Count'//引入connect 用于连接UI组件与reduximport &#123; connect &#125; from 'react-redux'import &#123; createIncrementAction, createDecrementAction, createIncrementAsyncAciton &#125; from '../../component/redux/count_aciton'//函数返回的对象中的key就座位传递给UI组件props的key value就座位传递给UI组件中的value-传递状态function mapStateToProps(state) &#123;  return &#123; count: state &#125;&#125;function mapDispatchToProps(dispatch) &#123;  return &#123;    jia: (number) => &#123;      dispatch(createIncrementAction(number))    &#125;,    jian: (number) => &#123;      dispatch(createDecrementAction(number))    &#125;,    jianAsync: (number, time) => &#123;      dispatch(createIncrementAsyncAciton(number, time))    &#125;  &#125;&#125;//创建Count的容器组件 const CountContainer = connect(mapStateToProps, mapDispatchToProps)(CountUI)export default CountContainer</code></pre><p>在countUI中不需要直接接触redux</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">import React, &#123; Component &#125; from 'react'export default class Count extends Component &#123;  increment = () => &#123;    const &#123; value &#125; = this.selectNumber    this.props.jia(value * 1)  &#125;  decrement = () => &#123;    const &#123; value &#125; = this.selectNumber    this.props.jian(value * 1)  &#125;  incrementIfOdd = () => &#123;  &#125;  incrementAsync = () => &#123;    const &#123; value &#125; = this.selectNumber    this.props.jianAsync(value * 1, 500)  &#125;  render() &#123;    return (      <div>        <h1>当前求和为:&#123;this.props.count&#125;</h1>        <select ref=&#123;c => this.selectNumber = c&#125;>          <option value="1">1</option>          <option value="2">2</option>          <option value="3">3</option>        </select>        <button onClick=&#123;this.increment&#125;>+</button>        <button onClick=&#123;this.decrement&#125;>-</button>        <button onClick=&#123;this.incrementIfOdd&#125;>当前求和为奇数再加</button>        <button onClick=&#123;this.incrementAsync&#125;>异步加</button>      </div>    )  &#125;&#125;</code></pre><p>创建Count容器的简写：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//创建Count的容器组件 const CountContainer = connect(  state => (&#123; count: state &#125;),  //一般写法  // dispatch => (  //   &#123;  //     jia: (number) => &#123;  //       dispatch(createIncrementAction(number))  //     &#125;,  //     jian: (number) => &#123;  //       dispatch(createDecrementAction(number))  //     &#125;,  //     jianAsync: (number, time) => &#123;  //       dispatch(createIncrementAsyncAciton(number, time))  //     &#125;  //   &#125;  // )  //简写：  &#123;    jia: createIncrementAction,    jian: createDecrementAction,    jianAsync: createIncrementAsyncAciton  &#125;)(CountUI)</code></pre><p>因为在每次使用容器的时候都要传入store 比较麻烦所以可以进行优化</p><p>在初始文件index.js中 引入store 和 Provider 将App总组件包裹起来然后传入store</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">import React from "react";import  ReactDOM  from "react-dom";import App from "./App";import  store from './component/redux/store'import &#123;Provider&#125; from 'react-redux'ReactDOM.render(  <Provider store=&#123;store&#125;>    <App/>  </Provider>  ,document.getElementById('root'))</code></pre><p>多个组件要使用redux 进行存储的时候。需要用到combineReducers </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//store//引入createStore，专门用于创建redux 中最为核心的store对象import &#123; createStore,applyMiddleware,combineReducers &#125; from 'redux'//引入为Count 组件服务的reducerimport countReducer from './reducer/count_reducer'import personReducer from './reducer/person'//引入redux-thunk import thunk from 'redux-thunk'const allReducer=combineReducers(&#123;  he:countReducer,  rens:personReducer&#125;)export default createStore(allReducer,applyMiddleware(thunk))</code></pre><ul><li><p>使用redux开发者工具</p><p>下载包：cnpm i  redux-devtools-extension</p></li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">//在store.js中//引入createStore创建redux最重要的store import &#123;createStore,combineReducers,applyMiddleware&#125; from 'redux'//导入count_reducerimport count_reducer from './reducer/count'import &#123;composeWithDevTools&#125; from 'redux-devtools-extension'import thunk from 'redux-thunk'const allReducer=combineReducers(&#123;   he:count_reducer&#125;)export default  createStore(allReducer,composeWithDevTools(applyMiddleware(thunk)))</code></pre><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul><li><p>懒加载</p><p> ```javascript<br> import React {component,lazy,Suspense} from ‘react’</p><p> //懒加载引入组件<br> const Home =lazy(()=&gt;import(‘./Home’))<br> const About=lazy(()=&gt;import(‘./About’))</p><p> //用Suspense 将注册的路由包裹起来然后指定一个fallback<br> <Suspense fallback="{<h1">Loading…<h1>}&gt;</h1></Suspense></p><pre><code>    &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt; &lt;Route path=&quot;/home&quot;  component=&#123;Home&#125;/&gt;</code></pre> <Suspense></Suspense></li></ul><pre><code>-  Hooks   - stateHook   让函数式组件可以使用state  React.useState  ```javascript  export default function Context() &#123;    //数组的解构赋值  第一个代表传入的state 第二个是设置state的方法    const [count, setCount] = React.useState(0)    function add() &#123;      //第一种写法      // setCount(count + 1)      //第二种写法      setCount(count =&gt; count + 1)    &#125;    return (      &lt;div&gt;        &lt;h2&gt;当前求和为:&#123;count&#125;&lt;/h2&gt;        &lt;button onClick=&#123;add&#125;&gt;点我+1&lt;/button&gt;      &lt;/div&gt;    )  &#125;</code></pre><ul><li><p>EffectHook</p><p>让函数式组件可以使用生命周期钩子</p><p>React.useEffect</p><p>这个相当于两个生命周期钩子  一个是componentDidMount 和componentDidUpdate</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">   //不写这个数组谁都检测，写这个空数组谁都不检测，在空数组中写[count]只检测count   React.useEffect(() => &#123;     console.log(1);   &#125;, [])import React from 'react' export default function Context() &#123;   //数组的解构赋值  第一个代表传入的state 第二个是设置state的方法   const [count, setCount] = React.useState(0)   function add() &#123;     setCount(count => count + 1)   &#125;   //不写这个数组谁都检测，写这个空数组谁都不检测，在空数组中写[count]只检测count   React.useEffect(() => &#123;     console.log(1);   &#125;, [])   return (     <div>       <h2>当前求和为:&#123;count&#125;</h2>       <button onClick=&#123;add&#125;>点我+1</button>     </div>   ) &#125;</code></pre><p>React.useEffect回调的返回值相当于componentWillOnMount可以用来清除定时器</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">  //不写这个数组谁都检测，写这个空数组谁都不检测，在空数组中写[count]只检测count  React.useEffect(() => &#123;    let timer = setInterval(() => &#123;      setCount(count => count + 1)    &#125;, 1000)    return () => &#123;      //相当于componentWillOnMount可以用来清除定时器      clearInterval(timer)    &#125;  &#125;, [])</code></pre><p><img src="/2021/Users\0\AppData\Roaming\Typora\typora-user-images\image-20220307145441422.png" alt="image-20220307145441422"></p></li></ul><ul><li><p>RefHook</p><p>在函数组件中使用ref</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">  //使用ref  const myRef = React.useRef()  <input type="text" ref=&#123;myRef&#125; />   function show() &#123;    alert(myRef.current.value)  &#125;</code></pre></li></ul><ul><li><p>Context</p><p>一种组件间通信方式 常用于祖组件与后代组件通信</p><p>1.创建Context对象</p><p>2.从Context 对象中引出Provider，将要传递的子组件用Provider包裹起来并指定要传的数据</p><p>3.在子组件中声明接收context</p></li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">import React, &#123; Component &#125; from 'react'//创建Context对象const MyContext = React.createContext()const &#123; Provider &#125; = MyContextexport default class A extends Component &#123;  state = &#123;    username: 'wuyang',    age: 18  &#125;  render() &#123;    const &#123; username, age &#125; = this.state    return (      <div>        <h2>我是A组件</h2>        <Provider value=&#123;&#123; username, age &#125;&#125;>          <B />        </Provider>      </div>    )  &#125;&#125;class B extends Component &#123;  //声明接收context  static contextType = MyContext  render() &#123;    const &#123; username, age &#125; = this.context    return (      <div>        我是B组件        <h4>接收到的&#123;username&#125;-&#123;age&#125;</h4>        <C />      </div>    )  &#125;&#125;class C extends Component &#123;  //声明接收context  static contextType = MyContext  render() &#123;    const &#123; username, age &#125; = this.context    return (      <div>        我是C组件        <h4>接收到的&#123;username&#125;-&#123;age&#125;</h4>      </div>    )  &#125;&#125;</code></pre><ul><li><p>PureComponent</p><p>component 存在一定的问题：</p><p>1.只要执行setState() 即使不改变状态数据，组件也会重新render()</p><p>2.只当前组件重新render()，就会自动重新render子组件。纵使子组件没有用到父组件的任何数据 ==》效率低</p></li></ul><p>解决方法：不使用component 使用PureComponent</p><ul><li><p>renderProps</p><p>父组件中使用子组件的另一种方式：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">export default class parent extends Component &#123; render() &#123;   return (     <div>       <h3>我是Parent组件</h3>       <A render=&#123;(name, age) => <B name=&#123;name&#125; age=&#123;age&#125; />&#125; />     </div>   ) &#125;&#125;</code></pre><p>相当于表明当前在parent组件中使用了A组件，A组件中又使用了B组件。但是B组件要进行使用还需要在A组件中接收一下 {this.props.render()}</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">class A extends Component &#123; state = &#123;   username: 'wuyang',   age: 18 &#125; render() &#123;   const &#123; username, age &#125; = this.state   return (     <div>       <h2>我是A组件</h2>       &#123;this.props.render(username,age)&#125;     </div>   ) &#125;&#125;</code></pre><p>在B组件中接收到得参数使用</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">class B extends Component &#123; render() &#123;   return (     <div>       我是B组件       <h4>接收到的&#123;this.props.name&#125;,&#123;this.props.age&#125;</h4>       <C />     </div>   ) &#125;&#125;</code></pre></li><li><p>错误边界 </p></li></ul><p><img src="/2021/Users\0\AppData\Roaming\Typora\typora-user-images\image-20220307101230856.png" alt="image-20220307101230856"></p><ul><li>组件通信</li></ul><p><img src="/2021/Users\0\AppData\Roaming\Typora\typora-user-images\image-20220307103649028.png" alt="image-20220307103649028"></p><h3 id="React-Router6的使用"><a href="#React-Router6的使用" class="headerlink" title="React Router6的使用"></a>React Router6的使用</h3><ul><li><p>Router5中 注册路由使用component</p><p>Router6中</p></li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript"><Routers>    <Route path="/about" element=&#123;<About/>&#125; > <Routers/></code></pre><ul><li>重定向</li></ul><p>Router5 中使用Redirect</p><p>Router6中 使用Navigate进行重定向</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"><Routes>    <Route path="/" element=&#123;<Navigate to="/about"/>&#125;><Routes/></code></pre><ul><li>Routes与Route </li></ul><p><img src="/2021/Users\0\AppData\Roaming\Typora\typora-user-images\image-20220307150517405.png" alt="image-20220307150517405"></p><ul><li><p>NavLink高亮</p><p>{isActive}是解构出来isActive 选中是为true没有选中时为flase</p></li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">//路由连接 atguigu 是自定义高亮的样式<NavLink className=&#123;(&#123;isActive=>&#123;return isactive?'list-group-item atguigu':'list-group-item '&#125;&#125;) to="/about"&#125;>About<NavLink>//复用写法    function computedClassName(&#123;isActive&#125;)&#123;    return isActive ? 'list-group-item atguigu'&#125;    <NavLink className=&#123;computedClassName&#125; to="/about">About<NavLink/></code></pre><ul><li><p>路由表</p><p>1.引入useRoutes</p><p><img src="/2021/Users\0\AppData\Roaming\Typora\typora-user-images\image-20220307151644425.png" alt="image-20220307151644425"></p><p>2.创建路由表</p><p>```java<br>const elements=useRoutes([{<br>   path:”/about”,<br>   element:<About><br>},{<br>   path:”/home”,<br>   element:<Home><br>},{<br>   path:”/“,  //重定向<br>   element:<Navigate to="/about"><br>}])</Navigate></Home></About></p></li></ul><p>   //注册路由直接使用路由表</p><p>  {elements}   </p><pre><code>  ![image-20220307152054768](C:\Users\0\AppData\Roaming\Typora\typora-user-images\image-20220307152054768.png)  上方图片中一堆相当于创建的路由表也就是&#123;elements&#125;-  嵌套路由  ![image-20220307152646294](C:\Users\0\AppData\Roaming\Typora\typora-user-images\image-20220307152646294.png)和vue中的基本一样路由注册```javascript//功能指定路由组件呈现在哪里 important &#123;Outlet&#125; from &#39;react-router-dom&#39;//指定路由组件呈现的位置&lt;Outlet /&gt;</code></pre><ul><li>路由传参 <ul><li><ol><li>路由的params参数</li></ol></li></ul></li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">//传入id，title，content参数<Link to=&#123;`detail/$&#123;m.id&#125;/$&#123;m.title&#125;/$&#123;m.content&#125;`&#125;>&#123;m.title&#125;</Link></code></pre><p>在路由表中声明要传入的参数</p><p><img src="/2021/Users\0\AppData\Roaming\Typora\typora-user-images\image-20220307154359815.png" alt="image-20220307154359815"></p><p>在路由组件中使用时，因为函数式组件this是undefined所以需要借助useParams</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">import &#123;useParams&#125; from 'react-router-dom'//从useParams中解构出来const &#123;id,title,content&#125; =useParams()</code></pre><p>​           2.路由的search参数</p><p>search 用问号进行分割</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"><Link to=&#123;`detail?id=&#123;m.id&#125;&title=$&#123;m.title&#125;&content=$&#123;m.content&#125;`&#125;>&#123;m.title&#125;</Link></code></pre><p>不用占位规则</p><p>在组件中使用：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">import &#123;useSearchParams&#125; from 'react-router-dom'//需要解构数组进行使用const [search,setSearch]=useSearchParams//需要使用get方法然后得到具体的参数const id=search.get('id')cosnt title=search.get('title')//使用setSearch进行更新<button onClick=&#123;()=>&#123;setSearch('id=001&title=哈哈&content="66"')&#125;&#125;></code></pre><p>​            3.路由的state参数</p><pre class=" language-lang-javascript"><code class="language-lang-javascript"><Link to="detail" state=&#123;&#123;id:m.id,title:m.title,content:m.content&#125;&#125;></code></pre><p>在组件中使用：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">import &#123;useLocation&#125; from 'react-router-dom'//连续解构赋值const &#123;state:&#123;id,title,content&#125;&#125; =useLocation()</code></pre><ul><li>编程式路由导航</li></ul><p>引入useNavigate</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const navigate=useNavigate()//使用编程式导航function show(m)&#123;    navigate('detail',&#123;        state:&#123;            id:m.id,            title:m.title,            content:m.content        &#125;    &#125;)&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue技巧</title>
      <link href="/2021/113050482.html"/>
      <url>/2021/113050482.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue技巧"><a href="#vue技巧" class="headerlink" title="vue技巧"></a>vue技巧</h1><h3 id="vue父组件调用子组件方法"><a href="#vue父组件调用子组件方法" class="headerlink" title="vue父组件调用子组件方法"></a>vue父组件调用子组件方法</h3><pre class=" language-lang-vue"><code class="language-lang-vue">//父组件<template><div father-component>    <Child ref="child"></Child>    <div @click="showChild">        点击按钮显示子组件    </div></div></template><script>import Child from ''export default&#123;    components:&#123;        Child    &#125;,    methods:&#123;        showChild()&#123;            const c=this.$ref.child            //调用子组件方法            c.showChild()        &#125;    &#125;&#125;</script>//子组件<template><div id="child-component">    我是子组件</div></template><script>export default&#123;    data()&#123;        return&#123;            isShow:false        &#125;    &#125;    methods:&#123;    //父组件将要调用的方法        showChild()&#123;            this.isShow=true        &#125;    &#125;&#125;</script></code></pre><h3 id="vue事件代理"><a href="#vue事件代理" class="headerlink" title="vue事件代理"></a>vue事件代理</h3><p>例子：在v-for循环外面调用index  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript"><div @click="onClick">    <li v-for="(item,index) in list" :key="item.id" :data-index="index"></li> </div>methods:&#123;    //在v-for循环的外部获取到当前点击循环的index,使用事件代理    onClick(e)&#123;        let index=e.target.getAttribute('data-index')        //这时候就可以获取到index    &#125;&#125;</code></pre><h3 id="vue代码执行"><a href="#vue代码执行" class="headerlink" title="vue代码执行"></a>vue代码执行</h3><p>详细执行顺序说明<br>在开发中我们还会涉及到props、data、computed、methods、watch等api，这几个常用的api的执行顺序可以结合源码分析；</p><p>以vue2.6为例，在vue/src/core/instance/init.js中有如下组件初始化时的执行代码</p><p><img src="https://img-blog.csdnimg.cn/20190628173716427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xVTkpJTkdKSUU=,size_16,color_FFFFFF,t_70" alt></p><p>进入initState(vm)方法，如下如所示</p><p><img src="https://img-blog.csdnimg.cn/20190628173723354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xVTkpJTkdKSUU=,size_16,color_FFFFFF,t_70" alt="图片"></p><p>可以知道，在initState方法中，初始化了props、methods、data、computed、watch这些API，且因为initState方法的执行顺序是在callHook(vm，‘beforeCreate’)之后，callHook(vm，‘created’)之前，所以执行顺序是介于beforeCreate与created之间；<br>需要注意的是，如在props、data、computed中定义的变量，在执行时是先把数据存在到内存当中，等到template模板渲染完成后，数据就会从内存写入到模板，取代模板中的模板字符串，完成赋值；<br>执行顺序总结<br>beforeCreate -&gt; state(data、computed等) -&gt; created -&gt; beforeMount -&gt; mounted -&gt; beforeUpdate -&gt; updated -&gt; beforeDestroy -&gt; destroyed<br>当数据变化后，虚拟DOM重新渲染页面前会触发beforeUpdate函数；<br>当虚拟DOM渲染页面，视图更新后，触发updated函数；</p><h3 id="vue通过nextTick获取最新的DOM"><a href="#vue通过nextTick获取最新的DOM" class="headerlink" title="vue通过nextTick获取最新的DOM"></a>vue通过nextTick获取最新的DOM</h3><p>vue 的dom更新是异步的，而且更新是批量</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2021/11251.html"/>
      <url>/2021/11251.html</url>
      
        <content type="html"><![CDATA[<h1 id="javascript-的数据结构"><a href="#javascript-的数据结构" class="headerlink" title="javascript 的数据结构"></a>javascript 的数据结构</h1><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>·  特点是先入先出  </p><p>  封装队列：  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">   //基于数组操作         function Queue() &#123;            this.items = []        &#125;        //方法        Queue.prototype = &#123;            //向队列尾部添加一个(多个)项            enquerue: function(element) &#123;                return this.items.push(element)            &#125;,            //溢出队列的第一项            dequeue: function() &#123;                return this.items.shift()            &#125;,            //返回队列中第一个元素            front: function() &#123;                return this.items[0]            &#125;,            //队列中不包含任何元素，返回true，否则返回false            isEmpty: function() &#123;                return this.items.length == 0            &#125;,            //返回队列包含的元素个数            size: function() &#123;                return this.items.length            &#125;,            //将队列中的内容，转成字符串            toString: function() &#123;                let result = ''                for (let i = 0; i < this.items.length; i++) &#123;                    result += this.items[i] + ''                &#125;                return result            &#125;        &#125;</code></pre><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>· 特点：先入后出  </p><p>封装栈结构  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">  //封装栈类        function Stack() &#123;            //栈中的属性            this.items = []        &#125;        Stack.prototype = &#123;            //将元素压入栈            push: function(element) &#123;                this.items.push(element)            &#125;,             //从栈中取出元素            pop: function() &#123;                return this.items.pop()            &#125;,            //查看栈顶元素            peek: function() &#123;                return this.items[this.items.length - 1]            &#125;,             //判断栈是否为空            isEmpty: function() &#123;                return this.items.length == 0            &#125;,            //获取栈中元素的个数            size: function() &#123;                return this.items.length            &#125;,            //tostring 方法            toString: function() &#123;                var resultString = ''                for (let i = 0; i < this.items.length; i++) &#123;                    resultString += this.items[i] + ''                &#125;                return resultString            &#125;        &#125;</code></pre><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>1.单向链表：单向链表中一般都有一个头节点，然后下面都是一个一个的节点。每一个节点中都有data和next。data中存储数据，next存储下一个节点的引用。  </p><p><img src="/2021/MyBlog\hexoblog\source\img\danxianglianbiao.png" alt="image-20211125132820517"></p><p>封装单向链表：  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">  //单向链表        function LinkedList() &#123;            //节点类            function Node(data) &#123;                this.data = data                this.next = null            &#125;            //属性            this.head = null            this.length = 0            //增加方法            LinkedList.prototype.append = function(data) &#123;                //创建新节点                var newNode = new Node(data)                    //判断是否是第一个节点                if (this.length == 0) &#123;                    this.head = newNode                &#125; else &#123;                    //不是第一个节点                    var current = this.head                        //判断head指针是否为null,为空向下执行，不为空指向下一个节点,判断是否是最后一个节点                    while (current.next) &#123;                        current = current.next                    &#125;                    current.next = newNode                &#125;                this.length++            &#125;            LinkedList.prototype.toString = function() &#123;                    var current = this.head                    var listString = ''                        //循环获取一个个节点                    while (current) &#123;                        listString += current.data + ''                        current = current.next                    &#125;                    return listString                &#125;                //插入方法            LinkedList.prototype.insert = function(position, data) &#123;                    if (position < 0 || position > this.length) return false                        //根据data 创建新节点                    var newNode = new Node(data)                        //判断插入的位置是否是第一个                    if (position == 0) &#123;                        newNode.next = this.head                        this.head = newNode                    &#125; else &#123;                        //插入的位置不是第一个                        var index = 0                        var current = this.head                        var previous = null                        while (index++ < position) &#123;                            previous = current                            current = current.next                        &#125;                        newNode.next = current                        previous.next = newNode                    &#125;                    this.length += 1                    return true                &#125;                //根据索引查找data            LinkedList.prototype.get = function(position) &#123;                    if (position < 0 || position >= this.length) return null                        //获取数据                    var current = this.head                    var index = 0                    while (index++ < position) &#123;                        current = current.next                    &#125;                    return current.data                &#125;                //根据元素查找元素的索引            LinkedList.prototype.indexOf = function(data) &#123;                    var index = 0                    var current = this.head                    while (current) &#123;                        if (current.data == data) &#123;                            return index                        &#125;                        current = current.next                        index += 1                    &#125;                    return -1                &#125;                //根据下标更新            LinkedList.prototype.update = function(position, element) &#123;                    if (position < 0 || position >= this.length) return false                    var current = this.head                    var index = 0                    while (index++ < position) &#123;                        current = current.next                    &#125;                    current.data = element                    return true                &#125;                //根据索引删除节点            LinkedList.prototype.removeAt = function(position) &#123;                    if (position < 0 || position >= this.length) return null                    var current = this.head                    if (position == 0) &#123;                        this.head = this.head.next                    &#125; else &#123;                        var index = 0                        var previous = null                        while (index++ < position) &#123;                            previous = current                            current = current.next                        &#125;                        previous.next = current.next                    &#125;                    this.length -= 1                    return current.data                &#125;                //根据数据删除节点            LinkedList.prototype.remove = function(data) &#123;                    var position = this.indexOf(data)                    return this.removeAt(position)                &#125;                //是否为空方法            LinkedList.prototype.isEmpty = function() &#123;                    return this.length == 0                &#125;                //size方法             LinkedList.prototype.size = function() &#123;                return this.length            &#125;        &#125;</code></pre><p>插入节点  </p><p><img src="/2021/MyBlog\hexoblog\source\img\danxianglianbiaoInsert.png" alt="image-20211125134111032"></p><p>就插入方法进行讲解：  </p><p>在position=0的时候，head指向的1节点。new(1)中的next存放的应该是1的地址也就是this.head(newNode.next = this.head)</p><p>而this.head中现在应该存放的就不是1的地址了，就应该是new(1)的地址。(this.head=newNode)  </p><p>在position不等于0的时候，2节点中本身存放的是3节点的地址。这时候想要插入一个节点就要让new(2)的next存放3的地址(newNode.next = current) 让2的next存放new(2)的地址( previous.next = newNode) 。此时current存放的应该是3的地址,</p><p>previous中存放的应该是2。</p><p>2.双向链表：  单向链表只可以向下指向，不可以向上指向。双向链表就完美的解决了这个问题。</p><p><img src="/2021/MyBlog\hexoblog\source\img\shuangxianglianbiao.png" alt="image-20211125140801956"></p><pre class=" language-lang-javascript"><code class="language-lang-javascript">   //封装双向链表        function DoublyLinkedList() &#123;            //属性            this.head = null            this.tail = null            this.length = 0                //内部类            function Node(data) &#123;                this.data = data                this.prex = null                this.next = null            &#125;            //常见的操作：方法            //向链表尾部追加数据            DoublyLinkedList.prototype.append = function(data) &#123;                    var newNode = new Node(data)                        // 判断是否添加的是第一个节点                    if (this.length == 0) &#123;                        this.head = newNode                        this.tail = newNode                    &#125; else &#123;                        this.tail.next = newNode                        newNode.prev = this.tail                        this.tail = newNode                    &#125;                    this.length += 1                &#125;                //将链表转成字符串形式            DoublyLinkedList.prototype.toString = function() &#123;                    return ""                &#125;                //向前遍历            DoublyLinkedList.prototype.forwardString = function() &#123;                    var current = this.tail                    var resultString = ""                    while (current) &#123;                        resultString += current.data + ""                        current = current.prev                    &#125;                    return resultString                &#125;                //向后遍历            DoublyLinkedList.prototype.backwordString = function() &#123;                    //定义变量                    var current = this.head                    var resultString = ""                    //依次向后遍历                    while (current) &#123;                        resultString += current.data + ""                        current = current.next                    &#125;                    return resultString                &#125;                //向列表的特定位置插入一个新的节点            DoublyLinkedList.prototype.insert = function(position, data) &#123;                    if (position < 0 || position > this.length) return false                    var newNode = new Node(data)                    if (this.length == 0) &#123;                        this.head = newNode                        this.tail = newNode                    &#125; else &#123;                        if (position == 0) &#123;                            this.head.prev = newNode                            newNode.next = this.head                            this.head = newNode                        &#125; else if (position == this.length) &#123;                            this.tail.next = newNode                            newNode.prev = this.tail                            this.tail = newNode                        &#125; else &#123;                            var current = this.head                            var previous = null                            var index = 0                            while (index++ < position) &#123;                                current = current.next                            &#125;                            newNode.next = current                            newNode.prev = current.prev                            current.prev.next = newNode                            current.prev = newNode                            console.log(newNode);                        &#125;                    &#125;                    this.length += 1                    return true                &#125;                //get方法            DoublyLinkedList.prototype.get = function(position) &#123;                if (position < 0 || position >= this.length) return null                var current = this.head                var index = 0                while (index++ < position) &#123;                    current = current.next                &#125;                return current.data            &#125;            DoublyLinkedList.prototype.indexOf = function(data) &#123;                var current = this.head                var index = 0                //查找和data相同的节点                while (current) &#123;                    if (current.data == data) &#123;                        return index                    &#125;                    current = current.next                    index += 1                &#125;                return -1            &#125;            DoublyLinkedList.prototype.update = function(position, newdata) &#123;                if (position < 0 || position >= this.length) return false                var current = this.head                var index = 0                while (index++ < position) &#123;                    current = current.next                &#125;                current.data = newdata                return true            &#125;            DoublyLinkedList.prototype.removeAt = function(position) &#123;                //越界判断                if (position < 0 || position >= this.length) return null                    //只有一项                var current = this.head                if (this.length == 1) &#123;                    this.head = null                    this.tail = null                &#125; else &#123;                    //判断删除的是否是第一个节点                    if (position == 0) &#123;                        this.head.next.prev = null                        this.head = this.head.next                    &#125; else if (position == this.length - 1) &#123;                        current = this.tail                        this.tail = this.tail.prev                        this.tail.prev.next = null                    &#125; else &#123;                        var index = 0                        while (index++ < position) &#123;                            current = current.next                        &#125;                        current.prev.next = current.next                        current.next.prev = current.prev                    &#125;                &#125;                this.length -= 1                return current.data            &#125;            DoublyLinkedList.prototype.remove = function(data) &#123;                var index = this.indexOf(data)                return this.removeAt(index)            &#125;            DoublyLinkedList.prototype.isEmpty = function() &#123;                return this.length == 0            &#125;            DoublyLinkedList.prototype.size = function() &#123;                    return this.length                &#125;                //获取链表的第一个元素            DoublyLinkedList.prototype.getHead = function() &#123;                return this.head.data            &#125;            DoublyLinkedList.prototype.getTail = function() &#123;                return this.tail.data            &#125;</code></pre><p><img src="/2021/MyBlog\hexoblog\source\img\shuangxianglianbaioInsert.png" alt="image-20211125142153288"></p><p>就插入讲解一下双向链表：  </p><p>1.插入元素是唯一元素：</p><p>让head和tail直接指向newNode</p><p>2.插入是第一个元素(positon=0)但不是唯一元素:  </p><p>让新节点的next指向1节点(newNode.next=this.head),让1节点的prev指向新节点(this.head.prev=newNode)让head指向新节点(this.head=newNode)，</p><p>3插入的是最后一个元素:  </p><p>让新节点prev指向上一个节点(newNode.prev=this.tail)让新节点的next指向null，让上一个节点的next指向新节点(this.tail.next=newNode)，让tail指向newNode(  this.tail = newNode)</p><p>4.让新节点的next指向下一个节点(newNode.next=current)，让新节点的prev指向上一个节点(newNode.prev=current.prev)</p><p>让上一个节点的next指向新节点(current.prev.next=newNode)，让下一个节点的prev指向新节点 (current.prev=newNode)</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">   //封装集合类         function Set() &#123;             //属性             this.items = &#123;&#125;                 //方法             Set.prototype.add = function(value) &#123;                 //判断当前集合中是否已经包含了该元素                 if (this.has(value)) &#123;                     return false                 &#125;                 this.items[value] = value                 return true             &#125;             Set.prototype.has = function(value) &#123;                 //hasOwnProperty判断对象中是否包含这个属性，存在就返回true 不存在返回false                 return this.items.hasOwnProperty(value)             &#125;             Set.prototype.remove = function(value) &#123;                 //判断该集合是否包含该元素                 if (!this.has(value)) &#123;                     return false                 &#125;                 delete this.items[value]                 return true             &#125;             Set.prototype.clear = function() &#123;                 this.items = &#123;&#125;                 return true             &#125;             Set.prototype.size = function() &#123;                     return Object.keys(this.items).length                 &#125;                 //获取集合中所有的值             Set.prototype.values = function() &#123;                     return Object.keys(this.items)                 &#125;                 //并集             Set.prototype.union = function(otherSet) &#123;                     var unionSet = new Set()                     var values = this.values()                     for (var i = 0; i < values.length; i++) &#123;                         unionSet.add(values[i])                     &#125;                     values = otherSet.values()                     for (var i = 0; i < values.length; i++) &#123;                         unionSet.add(values[i])                     &#125;                     return unionSet                 &#125;                 //交集             Set.prototype.intersection = function(otherSet) &#123;                     var intersection = new Set()                     var values = this.values()                     for (var i = 0; i < values.length; i++) &#123;                         var item = values[i]                         if (otherSet.has(item)) &#123;                             intersection.add(item)                         &#125;                     &#125;                     return intersection                 &#125;                 //差集             Set.prototype.difference = function(otherSet) &#123;                     var difference = new Set()                     var values = this.values()                     for (var i = 0; i < values.length; i++) &#123;                         var item = values[i]                         if (!otherSet.has(item)) &#123;                             difference.add(item)                         &#125;                     &#125;                     return difference                 &#125;                 //子集             Set.prototype.subset = function(otherSet) &#123;                 //遍历集合A中所有的元素                 var values = this.values()                 for (var i = 0; i < values.length; i++) &#123;                     var item = values[i]                     if (!otherSet.has(item)) &#123;                         return false                     &#125;                 &#125;                 return true             &#125;         &#125;</code></pre><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表的应用场景：  </p><p><img src="/2021/MyBlog\hexoblog\source\img\hashTable.png" alt="image-20211125165619023"></p><p>存储很多单词，当输入这个单词时候就可以获取到关于这个单词的一些信息 (翻译等)  </p><p>实现思路：将26个英文字母用自己所创建的编码符对应起来，通过Unicode和霍纳法则得到一个比较大的数字，在经过取余的操作限制下标的范围。然后根据这个下标去哈希表中对应的下标进行存储，因为取余操作可能会有重复。就会产生冲突，(解决冲突的方法有两种。我们这里使用的是链地址法)，所以我们不是直接将元素就存储在哈希表中，而是存储在哈希表中的桶(bucket)中。这个桶可以是链表也可以是数组(这里使用的是数组) </p><pre class=" language-lang-javascript"><code class="language-lang-javascript">  function hashFunc(str, size) &#123;            //定义hashCode变量            var hashCode = 0                //霍纳法则                //使用Unicode编码            for (var i = 0; i < str.length; i++) &#123;                //得到比较大的数字                hashCode = 37 * hashCode + str.charCodeAt(i)            &#125;            //取余操作            var index = hashCode % size            return index        &#125;</code></pre><p>封装哈希表：  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> function HashTable() &#123;            //属性            //数组            this.storage = []                //存放元素的数量            this.count = 0                //数组的长度            this.limit = 7            //哈希函数            HashTable.prototype.hashFunc = function(str, size) &#123;                    //定义hashCode变量                    var hashCode = 0                        //霍纳法则                        //使用Unicode编码                    for (var i = 0; i < str.length; i++) &#123;                        //得到比较大的数字                        hashCode = 37 * hashCode + str.charCodeAt(i)                    &#125;                    //取余操作                    var index = hashCode % size                    return index                &#125;                //插入修改操作            HashTable.prototype.put = function(key, value) &#123;                    //1.根据key 获取对应的index                    var index = this.hashFunc(key, this.limit)                        //2.根据index取出对应的buket                    var bucket = this.storage[index]                        //3判断没有桶就创建桶                    if (bucket == null) &#123;                        bucket = []                        this.storage[index] = bucket                    &#125;                    //4.判断是否是修改数据                    for (var i = 0; i < bucket.length; i++) &#123;                        //将桶中元素取出                        var tuple = bucket[i]                            //判断桶中是否有这个key                        if (tuple[0] == key) &#123;                            tuple[1] = value                            return                        &#125;                    &#125;                    //添加操作                    bucket.push([key, value])                    this.count += 1                    //判断是否需要进行扩容                    if (this.count > this.limit * 0.75) &#123;                        var newSize = this.limit * 2                        var newPrime = this.getPrime(newSize)                        this.resize(newPrime)                    &#125;                &#125;                //获取方法            HashTable.prototype.get = function(key) &#123;                    //根据key获取对应的index                    var index = this.hashFunc(key, this.limit)                        //获取对应的桶                    var bucket = this.storage[index]                        //如果桶为空直接返回null                    if (bucket == null) return null                        //遍历桶查找对应key                    for (var i = 0; i < bucket.length; i++) &#123;                        var tuple = bucket[i]                        if (tuple[0] == key) &#123;                            return tuple[1]                        &#125;                    &#125;                    return null                &#125;                //删除操作            HashTable.prototype.delete = function(key) &#123;                    var index = this.hashFunc(key, this.limit)                    var bucket = this.storage[index]                    if (bucket == null) return null                    for (var i = 0; i < bucket.length; i++) &#123;                        var tuple = bucket[i]                        if (tuple[0] == key) &#123;                            bucket.splice(i, 1)                            this.count--                                //删除缩小容量                                if (this.limit > 7 && this.count < this.limit * 0.25) &#123;                                    var newSize = Math.floor(this.limit / 2)                                    var newPrime = this.getPrime(newSize)                                    this.resize(newPrime)                                &#125;                            return tuple[1]                        &#125;                    &#125;                    return null                &#125;                //判断哈希表是否为空            HashTable.prototype.isEmpty = function() &#123;                    return this.count == 0                &#125;                //哈希表元素的个数            HashTable.prototype.size = function() &#123;                return this.count            &#125;            //哈希表的扩容            HashTable.prototype.resize = function(newLimit) &#123;                //1.保存旧的数组内容                var oldStorage = this.storage                    //重置所有的属性                this.storage = []                this.count = 0                this.limit = newLimit                    //遍历oldStorage所有的桶                for (var i = 0; i < oldStorage.length; i++) &#123;                    //取出对应的桶                    var bucket = oldStorage[i]                    if (bucket == null) &#123;                        continue                    &#125;                    for (var j = 0; j < bucket.length; j++) &#123;                        var tuple = bucket[j]                        this.put(tuple[0], tuple[1])                    &#125;                &#125;            &#125;            //判断某个数字是否是质数            HashTable.prototype.isPrime = function(num) &#123;                var temp = parseInt(Math.sqrt(num))                for (var i = 2; i <= temp; i++) &#123;                    if (num % i == 0) &#123;                        return false                    &#125;                &#125;                return true            &#125;            //获取质数的方法            HashTable.prototype.getPrime = function(num) &#123;                while (!this.isPrime(num)) &#123;                    num++                &#125;                return num            &#125;        &#125;</code></pre><p>如果我们哈希表存储的数据过多，这时候哈希表的效率就会下降。<img src="/2021/MyBlog\hexoblog\source\img\hash(1" alt="img">.png)</p><p>所以我们就需要对哈希表进行扩容</p><p><img src="/2021/MyBlog\hexoblog\source\img\hash(2" alt="img">.png)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vuex刷新数据丢失</title>
      <link href="/2021/111550482.html"/>
      <url>/2021/111550482.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用vuex进行持久层处理"><a href="#使用vuex进行持久层处理" class="headerlink" title="使用vuex进行持久层处理"></a>使用vuex进行持久层处理</h1><p>vuex中的数据是保存在内存当中的，如果浏览器进行刷新，vuex中的数据就会丢失。这时我们就需要进行持久层处理。  </p><p>原理：将需要做持久层的数据保存在浏览器中的localhostStorage或者是sessionStorage中  </p><pre class=" language-lang-javascript"><code class="language-lang-javascript"> //比如说我们存储用户信息 const store=new vuex.Store(&#123;     state:&#123;        userInfo:&#123;&#125;     &#125;,     mutations:&#123;         setUserInfo(state,data)&#123;             state.userInfo=data             //存入localhostStorage中             window.localhostStorage.userInfo=JSON.stringify(state.userInfo)         &#125;     &#125;,     //处理异步     actions:&#123;       loadUserInfo(&#123;commit&#125;)&#123;          //发起get请求           const &#123;data:res&#125;=this.$http.get('/api')           let userData=res           commit('setUserInfo',userData)       &#125;     &#125;   &#125;)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2.0 vue3.0数据代理数据劫持</title>
      <link href="/2021/110350482.html"/>
      <url>/2021/110350482.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue2-0-中响应式数据"><a href="#vue2-0-中响应式数据" class="headerlink" title="vue2.0 中响应式数据"></a>vue2.0 中响应式数据</h1><p>响应式数据：在页面上进行数据的改动 页面也会随之进行更新。<br>在 vue2.0 中我们在 data 中定义的数据都被 vue 进行了响应式处理。在 vue2.0 中对象 vue 底层是通过观察者模式和 Object.definePropety 进行数据代理和劫持。数组是通过包装 7 个数组方法进行响应式处理。<br>问题：</p><p>1.对象直接新添加的属性或删除已有属性，不会直接更新界面<br> 解决方案：</p><ul><li>删除操作：this.$delete(this.对象名,’属性名’)</li><li>新增操作：this.$set(this.对象名,’属性名’,’属性值’)</li></ul><hr><p>2.直接通过下标替换元素或更新数组的 length，界面不会直接更新</p><ul><li>更改 this.$set(this.数组名,索引,’值’)</li><li>使用数组的 7 个方法:push,pop,shift,unshift,splice,sort,reverse</li><li>删除 this.$delete(this.数组名,索引)</li><li>变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 filter()、concat() 和 slice()。它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组：</li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">example1.items = example1.items.filter(function (item) &#123;  return item.message.match(/Foo/)&#125;)</code></pre><p>你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作.</p><h1 id="vue3-0-中响应式数据"><a href="#vue3-0-中响应式数据" class="headerlink" title="vue3.0 中响应式数据"></a>vue3.0 中响应式数据</h1><p>vue3.0 中是通过代理和反射对数据进行数据劫持</p><h3 id="ref-修饰对基本类型的响应式"><a href="#ref-修饰对基本类型的响应式" class="headerlink" title="ref 修饰对基本类型的响应式"></a>ref 修饰对基本类型的响应式</h3><p>语法: const xxx = ref(initValue):</p><ul><li>创建一个包含响应式数据的引用(reference)对象</li><li>js 中操作数据: xxx.value</li><li>模板中操作数据: 不需要.value</li></ul><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><ul><li>作用: 定义多个数据的响应式</li><li>const proxy = reactive(obj): 接收一个普通对象然后返回该普通对象的响应式代理器对象</li><li>响应式转换是“深层的”：会影响对象内部所有嵌套的属性</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据都是响应式的</li></ul><p>原理：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const user = &#123;  name: 'John',  age: 12&#125;/*     proxyUser是代理对象, user是被代理对象    后面所有的操作都是通过代理对象来操作被代理对象内部属性    */const proxyUser = new Proxy(user, &#123;  get(target, prop) &#123;    console.log('劫持get()', prop)    return Reflect.get(target, prop)  &#125;,  set(target, prop, val) &#123;    console.log('劫持set()', prop, val)    return Reflect.set(target, prop, val) // (2)  &#125;,  deleteProperty(target, prop) &#123;    console.log('劫持delete属性', prop)    return Reflect.deleteProperty(target, prop)  &#125;&#125;)// 读取属性值console.log(proxyUser === user)console.log(proxyUser.name, proxyUser.age)// 设置属性值proxyUser.name = 'bob'proxyUser.age = 13console.log(user)// 添加属性proxyUser.sex = '男'console.log(user)// 删除属性delete proxyUser.sexconsole.log(user)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量提升函数提升，作用域，执行上下文理解</title>
      <link href="/2021/110350482.html"/>
      <url>/2021/110350482.html</url>
      
        <content type="html"><![CDATA[<h3 id="变量提升函数提升"><a href="#变量提升函数提升" class="headerlink" title="变量提升函数提升"></a>变量提升函数提升</h3><ul><li>变量提升<br>通常 JS 引擎会在正式执行之前先进行一次预编译，在这个过程中，首先将变量声明及函数声明提升至当前作用域的顶端，然后进行接下来的处理。(注：当前流行的 JS 引擎大都对源码进行了编译，由于引擎的不同，编译形式也会有所差异，我们这里说的预编译和提升其实是抽象出来的、易于理解的概念)<br>变量提升后的变量先定义到了 window 上，如果没有赋值先使用这时候变量的值是 undefind</li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">function test() &#123;  console.log(foo)  var foo = 5&#125;//这里输出结果是undefind并不是defind因为在预编译之后的代码是这样的</code></pre><pre class=" language-lang-javascript"><code class="language-lang-javascript">function test() &#123;  var foo  console.log(foo)  foo = 5&#125;</code></pre><ul><li>函数提升</li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">function test() &#123;  foo()  function foo() &#123;    console.log('可以执行函数') //这边函数是可以打印出这句话的  &#125;&#125;</code></pre><p>这段代码在预编译之后</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function test() &#123;  function foo() &#123;    console.log('可以执行函数')  &#125;  foo()&#125;</code></pre><p>在一个作用域中我们可以使用声明函数的方式，我们也有可能用到函数表达式的方式，如果名字相同怎么办呢</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function test()&#123;  foo()//2  var foo=funciton()&#123;    console.log(1)  &#125;  foo()//1  function foo()&#123;    console.log(2)  &#125;  foo()//1&#125;</code></pre><p>函数声明的优先级最高会被提升到顶部，然后函数声明会被后面的函数表达式覆盖所以后面的调用都是函数表达式。</p><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><ul><li>全局执行上下文<br>在全局代码执行之前会将 window 确定为全局执行上下文。然后对全局的数据进行预处理。var 定义的变量赋值为 undined，添加为 window 属性。function 声明的全局函数添加为 window 的方法。为 this 赋值为 window。最后开始执行全局代码。</li><li><p>函数(局部)执行上下文<br> 函数的执行上下文是在函数被调用的时候创建的。在函数体内代码执行之前，先创建函数执行上下文。1.形参变量==&gt;赋值(实参)2.arguments==&gt;(实参列表)3.var 定义的局部变量初始值为 undefind 添加为函数执行上下文的属性.4.function 声明的方法==&gt;赋值(fun)添加到执行上下文的方法。5.this==&gt;赋值(调用函数的对象)</p><p>理解：<br> 代码执行的时候先创建全局执行作用域，然后进行全局代码的执行。此时执行上下文栈中最底层是 window 执行上下文，当函数被调用时创建函数执行上下文栈。然后函数中代码执行完之后销毁。栈中只剩下 window 执行上下文。<br> 理解递归：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var i = 1foo(1)function foo() &#123;  if (i == 4) &#123;    retunrn  &#125;  console.log('fb:' + i)  foo(i + 1)  console.log('fe:' + i)&#125;</code></pre><p>理解这个递归的执行顺序：先创建 window 全局执行上下文，然后全局执行上下文入栈底。输出一次 fb：1。然后继续调用一直到 i 和 4 相等的时候。这个时候输出了 fb:1,fb:2,fb:3。栈中最底层的是 window 最上面是 f4 但是 f4 return 出去了，接着执行 f3 所以打印 fe:3。然后执行 f2 打印 fe:2 最后执行 f1 打印 fe:1 当函数执行完后会被直接销毁，最后栈中只剩下 window 上下文栈。</p></li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>1，在编写代码的时候函数的作用域就确定了<br>2，全局作用域，函数作用域：</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于axios各种请求方式的传参总结</title>
      <link href="/2021/102150482.html"/>
      <url>/2021/102150482.html</url>
      
        <content type="html"><![CDATA[<h1 id="axios-传参"><a href="#axios-传参" class="headerlink" title="axios 传参"></a>axios 传参</h1><p>这几天我在写我的 vue 项目后台接口，因为是第一次写所以我写遇到了一些小问题,axios 各种请求方式的传参数。基本将常用的请求方式都用过了所以现在总结一下。</p><h2 id="get-请求方式"><a href="#get-请求方式" class="headerlink" title="get 请求方式"></a>get 请求方式</h2><p>get 请求方式我使用的是 Params 进行传参,前端代码:</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const &#123; data: res &#125; = await this.$http.get(`/goods/query`, &#123;  params: &#123;    query: this.query  &#125;&#125;)</code></pre><p>然后后台接口接受传参</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let query = req.query.query</code></pre><h2 id="post-请求方式"><a href="#post-请求方式" class="headerlink" title="post 请求方式"></a>post 请求方式</h2><p>前端传参</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const &#123; data: res &#125; = await this.$http.post('/goods/increase', this.increaseInfo)</code></pre><p>接口接收参数</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let name = req.body.namelet price = req.body.pricelet type = req.body.typelet area = req.body.area</code></pre><h2 id="put-请求"><a href="#put-请求" class="headerlink" title="put 请求"></a>put 请求</h2><p>前端传参<br>第一种办法</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const &#123; data: res &#125; = await this.$http.put(`/goods/info/`, this.editInfo)</code></pre><p>后端接口</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let id = req.body.idid = parseInt(id)let name = req.body.namelet price = req.body.priceprice = parseInt(price)</code></pre><p>第二种办法<br>前端传参</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const &#123; data: res &#125; = await this.$http.put(`/goods/status/$&#123;numId&#125;/$&#123;status&#125;`)</code></pre><p>后端接口</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">router.put('/status/:id/:status', function (req, res) &#123;  goods.updateStatus(req, res)&#125;)let id = req.params.idlet status = req.params.status</code></pre><h2 id="delete-请求"><a href="#delete-请求" class="headerlink" title="delete 请求"></a>delete 请求</h2><p>前端传参</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const &#123; data: res &#125; = await this.$http.delete(`/goods/delete`, &#123;  data: &#123;    id: numId  &#125;&#125;)</code></pre><p>后端接口</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">req.body.id</code></pre><p>这样就可以简单的获取到了前端传过来的参数，有很多办法可以进行传参这只是我刚开始使用的方法，肯定有不好的地方。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Node写接口vue跨域问题Cors</title>
      <link href="/2021/101650482.html"/>
      <url>/2021/101650482.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue-跨域，同源策略"><a href="#vue-跨域，同源策略" class="headerlink" title="vue 跨域，同源策略"></a>vue 跨域，同源策略</h1><h2 id="同源策略："><a href="#同源策略：" class="headerlink" title="同源策略："></a>同源策略：</h2><p>同原策略就是协议，域名，端口号必须完全相同。因为前端经常会用到 Ajax 请求接口中的数据，Ajax 就遵循同源策略。所以我们就需要解决这个问题。因为我最近在用 node 写接口，然后用 vue 写前端进行渲染。遇到了这个跨域问题，所以我在网上找了很多解决方案。我只能说我现在不是很能理解这些解决方案的意思，以后慢慢理解。</p><h2 id="node-接口端："><a href="#node-接口端：" class="headerlink" title="node 接口端："></a>node 接口端：</h2><pre class=" language-lang-javascript"><code class="language-lang-javascript">// 处理cors跨域/* 全系统设置跨域处理 */// CORS & Preflight requestapp.use((req, res, next) => &#123;  if (req.path !== '/' && !req.path.includes('.')) &#123;    res.set(&#123;      'Access-Control-Allow-Credentials': true,      'Access-Control-Allow-Origin': req.headers.origin || '*',      'Access-Control-Allow-Headers': 'X-Requested-With,Content-Type',      'Access-Control-Allow-Methods': 'PUT,POST,GET,DELETE,OPTIONS',      'Content-Type': 'application/json; charset=utf-8'    &#125;)  &#125;  req.method === 'OPTIONS' ? res.status(204).end() : next()&#125;)</code></pre><h2 id="vue-端："><a href="#vue-端：" class="headerlink" title="vue 端："></a>vue 端：</h2><pre class=" language-lang-javascript"><code class="language-lang-javascript">import axios from 'axios'import qs from 'qs'axios.defaults.withCredentials = true // 允许跨域设置，不然可能因为拿不到cookie而报错axios.defaults.baseURL = 'http://localhost:3000/' /*这里的地址就是刚刚启起来的服务器地址,就是node端服务器的地址 *//*请求拦截*/axios.interceptors.request.use(  config => &#123;    if (config.meth === 'post' && !(config.data instanceof FormData)) &#123;      config.headers = &#123;        'Content-Type': 'application/x-www-form-urlencoded'      &#125;      config.data = qs.stringify(config.data, &#123;        arrayFormat: 'repeat'      &#125;) /*这里是，后端要求传数组的时候做的设置，以前出过错*/    &#125;    return config  &#125;,  error => &#123;    return Promise.reject(error)  &#125;)/* 响应拦截 */axios.interceptors.response.use(  res => &#123;    /*可在这里根据返回的状态码做一些拦截操作*/    return res  &#125;,  err => &#123;    return Promise.resolve(err)  &#125;)export default axios /*记得导出*/</code></pre><p>这两个设置完之后应该就不会出现跨域的问题，反正我测试的接口现在可以用 axios 请求到数据了，虽然我不是非常理解为什么这样写。但是有需求急迫解决这个问题的可以借鉴一下。</p><h2 id="vue-端代理处理跨域："><a href="#vue-端代理处理跨域：" class="headerlink" title="vue 端代理处理跨域："></a>vue 端代理处理跨域：</h2><p>在 vue 端可以使用代理服务器进行跨域</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//在vue.config.js中module.exports = &#123;  devServer: &#123;    port: 8081, // 此处修改你想要的端口号    proxy: &#123;      '/api': &#123;        target: 'http://172.16.3.33:8080',        changeOrigin: true,        pathRewrite: &#123;          '^/api': ''        &#125;      &#125;    &#125;  &#125;&#125;//请求时要加入前缀,例如这个请求const &#123; data: res &#125; = await this.$http.get('api/updateUser/1/update/666')</code></pre><p>代理服务器的原理就是，不同端口进行 ajax 会有同源策略的问题也就是跨域，当我们使用代理服务器，代理服务器的端口号是和 vue 相同的 这样就不会发生跨域。服务器和服务器之间是不会有跨域问题的</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2021/10121.html"/>
      <url>/2021/10121.html</url>
      
        <content type="html"><![CDATA[<h1 id="javascript-的设计模式"><a href="#javascript-的设计模式" class="headerlink" title="javascript 的设计模式"></a>javascript 的设计模式</h1><h2 id="模块化模式"><a href="#模块化模式" class="headerlink" title="模块化模式"></a>模块化模式</h2><p>模块化模式：让内部成员不外泄到全局中，将内部信息封装成一个模块。只能通过特定的方法才可以进行访问内部成员信息。比如说购物车中数组是不能直接让外部进行访问的，只能通过其域中特定的方法才可以进行访问。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var buy = (function () &#123;  var buyList = []  //增加购物车数据方法  function addItem(values) &#123;    buyList.push(values)  &#125;  //得到购物车数据数量的方法  function getItem() &#123;    conlose.log(buyList.length)  &#125;  return &#123;    addItem: addItem,    getItem: getItem  &#125;&#125;)()buy.addItem(&#123;  name: 'one',  price: 1&#125;)buy.addItem(&#123;  name: 'two',  price: 2&#125;)buy.getItem() //2console.log(buy.buyList) //这个是不可以直接访问的,直接访问的结果是undefined</code></pre><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式是一种十分常用但却相对而言比较简单的设计模式。它是指在一个类只能有一个实例，即使多次实例化该类，也只返回第一次实例化后的实例对象。单例模式不仅能减少不必要的内存开销, 并且在减少全局的函数和变量冲突也具有重要的意义。<br>使用闭包实现单例模式</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let Create = function () &#123;  let instance = null  return function (name) &#123;    this.name = name    if (instance) &#123;      return instance    &#125;    return (instance = this)  &#125;&#125;Create.prototype.getName = function () &#123;  console.log(this.name)&#125;let xiaoming = new Create('xiaoming')// console.log(xiaoming.getName());xiaoming.getName() //xiaominglet xiaoliu = new Create('xiaoliu')// console.log(xiaoliu.getName());xiaoliu.getName() //xiaoming</code></pre><p>利用一个变量 instance 判断是否已经创建实例，如果之前没有创建实例就将 this 传给 instance。当第二次创建实例的时候，虽然向构造函数中传入参数了但是因为 instance 已经存在 所以返回的还是上一次创建的实例。</p><h2 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h2><p>寄生式组合继承相对来说是最为好的一种继承方式</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//让子类原型继承父类原型function inheritObject(o)&#123;  //创建一个过渡函数对象  function F()&#123;&#125;  //让F的原型对象继承父类原型对象  F.prototype=o  //返回F实例，这个实例继承了父对象的原型  retun new F()&#125;//寄生式继承function inheritPrototype(subClass,superClass)&#123;  //创建父类原型副本，存储在变量中  var p=inheritObject(superClass.prototype)  //修正因为重写子类原型导致子类的 constructor属性被修改  p.constructor = subClass  //子类原型继承父类原型  subClass.prototype=p&#125;//构建父类构造对象function SuperClass(name)&#123;  this.name=name  this.colors=['red','black']&#125;//父类原型对象方法SuperClass.prototype.getName=function()&#123;  console.log(this.name)&#125;//构建子类构造对象function SubClass(name,time)&#123;  //继承父类构造  superClass.call(this,name)  this.time=time&#125;//子类原型对象方法SubClass.prototype.getTime()&#123;  console.log(this.time)&#125;//创建子类实例对象var instance1=new SubClass('app book',2020)var instance2=new SubClass('css book',2021)instance1.colors.push('blue')console.log(instance1.colors)//['red','black','blue']console.log(instance2.colors)//['red','black']instance2.getName()//css bookinstance2.getTime()//2021</code></pre><p>一开始我对 p.constructor = subClass 这句话有歧义，因为我感觉去掉也是可以的。但是我上网查询了一下资料。不把 constructor 指回子类是可以的，但是后面添加原型方法就会出现问题。constructor 一般在闭包不能直接访问的情况下可以通过 constructor 进行添加一些方法。</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>当我们实现登录功能的时候，我们可能会用到警示框，提示框各种有些区别的框框。我们第一个想到的是将其封装成一个一个方法。但是只能一味的封装类，可能每一个框中有一些东西出现了差异之后，这时我们就需要再创建一个类。这实在是太麻烦了</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//自定义警示框 不使用工厂类创建//需求：需要一个警示框，错误提示框，确认框(确认框中需要添加一个注册按钮)var LoginAlert = function (text) &#123;  this.content = text&#125;LoginAlert.prototype.show = function () &#123;  //显示警示框  console.log('显示警示框')&#125;//警示框//需要创建一个新类var LoginComfim = function (text) &#123;  this.content = text&#125;LoginComfim.prototype.show = function () &#123;  //展示确认框&#125;//当内容又有一点差异时var LoginPromat = function (text) &#123;  this.content = text&#125;LoginPromat.prototype.show = function () &#123;  //展示&#125;//使用简单工厂模式var PopFactory = function (name) &#123;  switch (name) &#123;    case 'alert':      return LoginAlert    case 'confim':      return LoginComfim    case 'prompt':      return LoginPromat  &#125;&#125;var Factory = new PopFactory('alert')var alert = new Factory('警示框')console.log(alert.content) //警示框alert.show() //显示警示框</code></pre><p>当我们使用了这个工厂之后，再注册模块中也可以使用在完成登录模块时封装的方法。而且我们只需要记住这个工厂就好。<br>但是我们发现这封装的三个类中有很多相似点，所以我们遇到这种情况需要使用另一种工厂模式</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//另一种简单工厂化模式function createPop(type, text) &#123;  //创建一个对象，并对对象拓展属性和方法  var o = new Object()  o.content = text  o.show = function () &#123;    //共有方法  &#125;  if (type == 'alert') &#123;    //警示框差异部分    console.log('2警示框')  &#125;  if (type == 'prompt') &#123;    //提示框差异部分    console.log('提示框')  &#125;  if (type == 'confim') &#123;    console.log('确认框')  &#125;  return o&#125;var userNameAlert = createPop('alert', '另一种工厂警示框') //2警示框console.log(userNameAlert.content) //另一种工厂警示框</code></pre><h2 id="安全类，安全工厂方法"><a href="#安全类，安全工厂方法" class="headerlink" title="安全类，安全工厂方法"></a>安全类，安全工厂方法</h2><p>我们在使用类的时候如果不进行实例的话，可能就会出现问题。小白可能在实例化的时候忘记 new 关键字。这个时候就可能出现一些问题。所以我们需要使用安全类</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//不使用安全模式的类var Demo = function () &#123;&#125;Demo.prototype = &#123;  show: function () &#123;    console.log('成功获取')  &#125;&#125;var demo = new Demo()demo.show() //成功获取var demo2 = Demodemo2.show() //报错//安全模式类var Test = function () &#123;  if (!(this instanceof Test)) &#123;    return new Test()  &#125;&#125;Test.prototype = &#123;  show: function () &#123;    console.log('安全获取')  &#125;&#125;var d = Test()d.show() //安全获取</code></pre><p>我们上面说了怎样使用简单工厂模式，但是当我们需求过多的时候。我们不仅仅要添加类，还要修改工厂函数。这简直更加麻烦。所以我们这时候可以使用安全工厂方法</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var Factory = function (type, count) &#123;  if (this instanceof Factory) &#123;    //这时候使用者new了实例,返回对应的方法    let s = new this[type](count)    return s  &#125; else &#123;    //这时使用者没有new，应该构造一个工厂实例然后返回    return new Factory(type, count)  &#125;&#125;//添加工厂方法Factory.prototype = &#123;  java: function (count) &#123;    consloe.log(count)  &#125;,  javascript: function (count) &#123;    consloe.log(count)  &#125;&#125;var use = Factory('java', '使用java') // 使用java//我们使用的时候 无论使不使用new 都可以使用工厂中的方法</code></pre><p>当我们没有使用 new 的时候 这时候的 this 指向的 window 全局对象，所以 this instanceof Factory 这个就时 false 然后代码执行 else{} 返回了一个实例的 Factory 然后这时候的 this 指向的就是 Factory 了。然后 this 其实就是这个工厂构造，然后里面有这几个工厂方法.this[type]=this.java。 所以返回的 s 其实就是 java 这个方法了。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂更加体现类的继承关系。一般是先创建抽象工厂，然后创建具体抽象工厂，最后是产品。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//创建抽象工厂类var AbstractFactory = function (subType, superType) &#123;  //判断抽象工厂中是否有此具体抽象工厂  if (typeof AbstractFactory[superType] === 'function') &#123;    //创建缓存类    var F = function () &#123;&#125;    //继承抽象工厂类的属性    F.prototype = new AbstractFactory[superType]()    //指回    subType.constructor = subType    //子类继承父类    subType.prototype = new F()  &#125; else &#123;    return '没有此抽象工厂'  &#125;&#125;//创建具体抽象工厂AbstractFactory.Car = function () &#123;  this.type = 'car'&#125;//创建抽象产品类var BWM = function (price, speed) &#123;  this.price = price  this.speed = speed&#125;//继承父类(具体抽象工厂)AbstractFactory(BWM, 'Car')//抽象产品类的方法BWM.prototype.getPrice = function () &#123;  return this.price&#125;BWM.prototype.getSpeed = function () &#123;  return this.speed&#125;//创建具体产品var threeXi = new BWM('价格', '速度')conlog.log(threeXi.getPrice()) //价格conlog.log(threeXi.getSpeed()) //速度</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对象方法</title>
      <link href="/2021/10101.html"/>
      <url>/2021/10101.html</url>
      
        <content type="html"><![CDATA[<h1 id="js-object-的内置方法"><a href="#js-object-的内置方法" class="headerlink" title="js object 的内置方法"></a>js object 的内置方法</h1><h2 id="Object-assign-用法"><a href="#Object-assign-用法" class="headerlink" title="Object.assign()用法"></a>Object.assign()用法</h2><p>·对象的拷贝<br>该方法用于将所有可枚举属性的值从一个或多个源对象（sources）分配到目标对象（target），并返回目标对象。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let target = &#123; a: 1, b: 2 &#125;let sources1 = &#123; a: 2, b: 3 &#125;let sources2 = &#123; a: 3, b: 4 &#125;let obj = Object.assign(target, sources1, sources2)console.log(obj)//a:3 b:4</code></pre><p>注意：</p><p>1、源对象属性与目标对象属性不同，则会被拷贝到目标对象中;<br>2、如果目标对象和源对象有相同的属性，目标对象的属性值会被源对象的属性值覆盖掉;<br>3、如果有多个源对象有相同的属性，那么目标对象的属性将会被最后一个源对象属性覆盖。</p><p>使用这个方法进行拷贝进行的是深拷贝，继承和枚举的属性不可以使用 assign 进行拷贝</p><h2 id="Object-defineProperty-用法"><a href="#Object-defineProperty-用法" class="headerlink" title="Object.defineProperty()用法"></a>Object.defineProperty()用法</h2><p>·该方法允许精确地添加或修改对象的属性。通过赋值操作添加的普通属性是可枚举的，在枚举对象属性时会被枚举到（for…in 或 Object.keys 方法），可以改变这些属性的值，也可以删除这些属性。这个方法允许修改默认的额外选项（或配置）。默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改（immutable）的。<br>·使用方法:</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const target = &#123;&#125;Object.defineProperty(target, 'foo', &#123;  configurable: false,  writable: false,  vakue: 'Test'&#125;)</code></pre><p>上面的代码就给 target 这个对象添加一个 foo 属性，而且这个属性的值为 Test。当 configurable 为 false 的时候这个属性不可以改变。当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符改变。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue-music-pc项目</title>
      <link href="/2021/092950482.html"/>
      <url>/2021/092950482.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue-music-pc-项目"><a href="#vue-music-pc-项目" class="headerlink" title="vue-music-pc 项目"></a>vue-music-pc 项目</h1><ul><li>这个项目是我自己动手做的第一个项目，完全靠自己做的，所以 css 写的不好，有一些逻辑写的也不是很好，后来再慢慢去优化吧，项目还没有上线。但是我的代码都放到了 GitHub 和 gitee 上了，一些东西还是有帮助的。</li><li>这里是 GitHub 的地址 <a href="https://github.com/wuyang147258/vue-music-pc">vue 网易云(github)</a> 这个是 gitee 的地址 <a href="https://gitee.com/ycwuyang/vue-music-pc">vue 网易云(gitee)</a> 这个是我用的后台接口 <a href="https://binaryify.github.io/NeteaseCloudMusicApi/#/">网易云后台接口</a></li><li>技术栈：vue+vuex+element-ui</li></ul><h2 id="开发前的准备："><a href="#开发前的准备：" class="headerlink" title="开发前的准备："></a>开发前的准备：</h2><ul><li>在我们进行痛快淋漓的写业务逻辑之前必然是需要配置一些插件依赖什么的。这里我 ui 框架是用的 element-ui 这个是开源的框架，功能还是比较齐全的。在 vue-cli 的使用方法我已经给大家找好了。<a href="https://blog.csdn.net/u013350495/article/details/103533320?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163288625116780264060046%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163288625116780264060046&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-103533320.first_rank_v2_pc_rank_v29&amp;utm_term=vue-ui%E6%8C%89%E9%9C%80%E5%AF%BC%E5%85%A5element-ui&amp;spm=1018.2226.3001.4187">按需导入 element-ui</a> 还有的就是 axios 库，这个比较简单安装一下就可以了。下面最重要的一点也是我踩过的坑，我最想给大家说的。就是在你访问后台接口的时候会出现跨域的问题，大家可能以前也遇到过满难受的。这是我用的解决方案源码：</li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">import axios from 'axios'import qs from 'qs'axios.defaults.withCredentials = true // 允许跨域设置，不然可能因为拿不到cookie而报错axios.defaults.baseURL = 'http://localhost:3000/' /*这里的地址就是刚刚启起来的服务器地址  *//*请求拦截*/axios.interceptors.request.use(  config => &#123;    if (config.meth === 'post' && !(config.data instanceof FormData)) &#123;      config.headers = &#123;        'Content-Type': 'application/x-www-form-urlencoded'      &#125;      config.data = qs.stringify(config.data, &#123;        arrayFormat: 'repeat'      &#125;) /*这里是，后端要求传数组的时候做的设置，以前出过错*/    &#125;    return config  &#125;,  error => &#123;    return Promise.reject(error)  &#125;)/* 响应拦截 */axios.interceptors.response.use(  res => &#123;    /*可在这里根据返回的状态码做一些拦截操作*/    return res  &#125;,  err => &#123;    return Promise.resolve(err)  &#125;)export default axios /*记得导出*/</code></pre><p>解决了以上问题之后我们就可以愉快的进行项目开发了！！!</p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>登录功能的思路很简单。第一先设置一个路由导航，阻止用户不进行登录就进入主页。第二获取后台接口进行登录(我使用了手机验证码登录和密码登录)，成功登录之后需要获取一个登录状态要不然后面的一些功能可能没有办法使用。</p><h2 id="歌曲实现播放"><a href="#歌曲实现播放" class="headerlink" title="歌曲实现播放"></a>歌曲实现播放</h2><p>在 pc 端上面怎么实现歌曲播放呢，我首先想到的是 audio 标签。然后就想要将音乐的 url 放到 audio 的 src 上应该就可以进行播放了。这是我当时写的时候的思路。因为组件的复用，所以我把 audio 放到了主页上，这样不管以后再增加什么歌曲或者歌单将这个歌曲的 id 存入到 vuex 中就可以拿到歌曲的 url，然后通过 ref 就可以设置 audio 的 src 进行歌曲的播放了。组件的复用还可以，省了不少麻烦。</p><h2 id="歌曲详情页面-歌词滚动实现"><a href="#歌曲详情页面-歌词滚动实现" class="headerlink" title="歌曲详情页面(歌词滚动实现)"></a>歌曲详情页面(歌词滚动实现)</h2><p>因为其他的东西不算特别难，业务逻辑基本都是一样的都是获取后台接口的数据然后进行渲染，没有什么稀奇的东西。我感觉这个歌词的滚动还算比较难，因为我在做的时候费了不少力气，也看了不少人的博客。这个解决方案是我看一个教学视频上看到的。<br>思路就是将后台获取到的歌词数据处理成一个时间段一句歌词的格式。然后获取当前歌曲播放的时间让这个时间大于上一句歌词的时间小于下一句歌词的时间，思路就是这样。下面附上歌词处理的代码，后面还要加上 css 的动画滚动。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//这里是处理歌词格式和实现歌词滚动的代码//处理歌词方法       formatTimeToSec(value)&#123;                    let arr = value.split(':');                    return (Number(arr[0]*60) +  Number(arr[1])).toFixed(1);            &#125;,   //处理歌词方法   proLyric(lyric)&#123;     //利用正则处理歌词                        // console.log(lyric)                        let re=/\[([^\]]+)\]([^\[]+)/g                        var result=[];                        lyric.replace(re,($0,$1,$2)=>&#123;                            result.push(&#123;"time":this.formatTimeToSec($1),"lyric":$2&#125;)                        &#125;)                        this.songLyric=result   &#125;,   //实现歌词滚动   //实现歌词滚动            listenLyricIndex()&#123;                //清除之前存在的计时器                clearInterval(this.timer)                this.timer=setInterval(()=>&#123;                    for(var i=0;i<this.songLyric.length;i++)&#123;                        if(this.$store.state.currentTime>this.songLyric[this.songLyric.length-1].time)&#123;                            this.lyricIndex=this.songLyric.length-1                            break;                        &#125;                        if(this.$store.state.currentTime>this.songLyric[i].time && this.$store.state.currentTime<this.songLyric[i+1].time)&#123;                            this.lyricIndex=i                        &#125;                    &#125;                &#125;,500)            &#125;,            //关闭定时器            cancelLyriIdex()&#123;                clearInterval(this.timer)            &#125;,</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客小试牛刀</title>
      <link href="/2021/092839553.html"/>
      <url>/2021/092839553.html</url>
      
        <content type="html"><![CDATA[<h1 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h1><h2 id="一个前端小白的成长经历"><a href="#一个前端小白的成长经历" class="headerlink" title="一个前端小白的成长经历"></a>一个前端小白的成长经历</h2><ul><li>见证了自己的成长，真的很幸福。从大一到现在一直一个人在自学，到现在可以做一些<br>有趣的东西，可以做一些好玩的东西感觉真好。虽然自己出了很多 bug，但是基本上也都<br>上网进行了解决，也有看见困难就退缩的时候，比如这个博客一开始我就没有搭建好，<br>然后放弃了搭建。几天后我又重拾进行搭建。现在终于成功了，所以不是办不到，只是<br>看自己想不想干了。</li></ul><h2 id="可爱的小猫"><a href="#可爱的小猫" class="headerlink" title="可爱的小猫"></a>可爱的小猫</h2><p>以后在能养活自己的前提养一只小猫！<br><img src="https://th.bing.com/th/id/R.f18f12a4ba5ae21a01bd8a8ecae7fa42?rik=5S8Pjv29%2fYLEnA&amp;pid=ImgRaw&amp;r=0" alt></p><h2 id="vue-网易云"><a href="#vue-网易云" class="headerlink" title="vue 网易云"></a>vue 网易云</h2><p>这是自己做的 pc 端网易云，完全自己做。我样式搞得不是很好，需要重新加工。<br>这是 GitHub 地址 <a href="https://github.com/wuyang147258/vue-music-pc">vue 网易云</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 成长经历 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
