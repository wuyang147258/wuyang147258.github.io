<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue2.0 vue3.0数据代理数据劫持</title>
      <link href="/2021/110350482.html"/>
      <url>/2021/110350482.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue2-0-中响应式数据"><a href="#vue2-0-中响应式数据" class="headerlink" title="vue2.0 中响应式数据"></a>vue2.0 中响应式数据</h1><p>响应式数据：在页面上进行数据的改动 页面也会随之进行更新。<br>在 vue2.0 中我们在 data 中定义的数据都被 vue 进行了响应式处理。在 vue2.0 中对象 vue 底层是通过观察者模式和 Object.definePropety 进行数据代理和劫持。数组是通过包装 7 个数组方法进行响应式处理。<br>问题：</p><p>1.对象直接新添加的属性或删除已有属性，不会直接更新界面<br> 解决方案：</p><ul><li>删除操作：this.$delete(this.对象名,’属性名’)</li><li>新增操作：this.$set(this.对象名,’属性名’,’属性值’)</li></ul><hr><p>2.直接通过下标替换元素或更新数组的 length，界面不会直接更新</p><ul><li>更改 this.$set(this.数组名,索引,’值’)</li><li>使用数组的 7 个方法:push,pop,shift,unshift,splice,sort,reverse</li><li>删除 this.$delete(this.数组名,索引)</li><li>变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 filter()、concat() 和 slice()。它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组：</li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">example1.items = example1.items.filter(function (item) &#123;  return item.message.match(/Foo/)&#125;)</code></pre><p>你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作.</p><h1 id="vue3-0-中响应式数据"><a href="#vue3-0-中响应式数据" class="headerlink" title="vue3.0 中响应式数据"></a>vue3.0 中响应式数据</h1><p>vue3.0 中是通过代理和反射对数据进行数据劫持</p><h3 id="ref-修饰对基本类型的响应式"><a href="#ref-修饰对基本类型的响应式" class="headerlink" title="ref 修饰对基本类型的响应式"></a>ref 修饰对基本类型的响应式</h3><p>语法: const xxx = ref(initValue):</p><ul><li>创建一个包含响应式数据的引用(reference)对象</li><li>js 中操作数据: xxx.value</li><li>模板中操作数据: 不需要.value</li></ul><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><ul><li>作用: 定义多个数据的响应式</li><li>const proxy = reactive(obj): 接收一个普通对象然后返回该普通对象的响应式代理器对象</li><li>响应式转换是“深层的”：会影响对象内部所有嵌套的属性</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据都是响应式的</li></ul><p>原理：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const user = &#123;  name: 'John',  age: 12&#125;/*     proxyUser是代理对象, user是被代理对象    后面所有的操作都是通过代理对象来操作被代理对象内部属性    */const proxyUser = new Proxy(user, &#123;  get(target, prop) &#123;    console.log('劫持get()', prop)    return Reflect.get(target, prop)  &#125;,  set(target, prop, val) &#123;    console.log('劫持set()', prop, val)    return Reflect.set(target, prop, val) // (2)  &#125;,  deleteProperty(target, prop) &#123;    console.log('劫持delete属性', prop)    return Reflect.deleteProperty(target, prop)  &#125;&#125;)// 读取属性值console.log(proxyUser === user)console.log(proxyUser.name, proxyUser.age)// 设置属性值proxyUser.name = 'bob'proxyUser.age = 13console.log(user)// 添加属性proxyUser.sex = '男'console.log(user)// 删除属性delete proxyUser.sexconsole.log(user)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于axios各种请求方式的传参总结</title>
      <link href="/2021/102150482.html"/>
      <url>/2021/102150482.html</url>
      
        <content type="html"><![CDATA[<h1 id="axios-传参"><a href="#axios-传参" class="headerlink" title="axios 传参"></a>axios 传参</h1><p>这几天我在写我的 vue 项目后台接口，因为是第一次写所以我写遇到了一些小问题,axios 各种请求方式的传参数。基本将常用的请求方式都用过了所以现在总结一下。</p><h2 id="get-请求方式"><a href="#get-请求方式" class="headerlink" title="get 请求方式"></a>get 请求方式</h2><p>get 请求方式我使用的是 Params 进行传参,前端代码:</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const &#123; data: res &#125; = await this.$http.get(`/goods/query`, &#123;  params: &#123;    query: this.query  &#125;&#125;)</code></pre><p>然后后台接口接受传参</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let query = req.query.query</code></pre><h2 id="post-请求方式"><a href="#post-请求方式" class="headerlink" title="post 请求方式"></a>post 请求方式</h2><p>前端传参</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const &#123; data: res &#125; = await this.$http.post('/goods/increase', this.increaseInfo)</code></pre><p>接口接收参数</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let name = req.body.namelet price = req.body.pricelet type = req.body.typelet area = req.body.area</code></pre><h2 id="put-请求"><a href="#put-请求" class="headerlink" title="put 请求"></a>put 请求</h2><p>前端传参<br>第一种办法</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const &#123; data: res &#125; = await this.$http.put(`/goods/info/`, this.editInfo)</code></pre><p>后端接口</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let id = req.body.idid = parseInt(id)let name = req.body.namelet price = req.body.priceprice = parseInt(price)</code></pre><p>第二种办法<br>前端传参</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const &#123; data: res &#125; = await this.$http.put(`/goods/status/$&#123;numId&#125;/$&#123;status&#125;`)</code></pre><p>后端接口</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">router.put('/status/:id/:status', function (req, res) &#123;  goods.updateStatus(req, res)&#125;)let id = req.params.idlet status = req.params.status</code></pre><h2 id="delete-请求"><a href="#delete-请求" class="headerlink" title="delete 请求"></a>delete 请求</h2><p>前端传参</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const &#123; data: res &#125; = await this.$http.delete(`/goods/delete`, &#123;  data: &#123;    id: numId  &#125;&#125;)</code></pre><p>后端接口</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">req.body.id</code></pre><p>这样就可以简单的获取到了前端传过来的参数，有很多办法可以进行传参这只是我刚开始使用的方法，肯定有不好的地方。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Node写接口vue跨域问题Cors</title>
      <link href="/2021/101650482.html"/>
      <url>/2021/101650482.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue-跨域，同源策略"><a href="#vue-跨域，同源策略" class="headerlink" title="vue 跨域，同源策略"></a>vue 跨域，同源策略</h1><h2 id="同源策略："><a href="#同源策略：" class="headerlink" title="同源策略："></a>同源策略：</h2><p>同原策略就是协议，域名，端口号必须完全相同。因为前端经常会用到 Ajax 请求接口中的数据，Ajax 就遵循同源策略。所以我们就需要解决这个问题。因为我最近在用 node 写接口，然后用 vue 写前端进行渲染。遇到了这个跨域问题，所以我在网上找了很多解决方案。我只能说我现在不是很能理解这些解决方案的意思，以后慢慢理解。</p><h2 id="node-接口端："><a href="#node-接口端：" class="headerlink" title="node 接口端："></a>node 接口端：</h2><pre class=" language-lang-javascript"><code class="language-lang-javascript">// 处理cors跨域/* 全系统设置跨域处理 */// CORS & Preflight requestapp.use((req, res, next) => &#123;  if (req.path !== '/' && !req.path.includes('.')) &#123;    res.set(&#123;      'Access-Control-Allow-Credentials': true,      'Access-Control-Allow-Origin': req.headers.origin || '*',      'Access-Control-Allow-Headers': 'X-Requested-With,Content-Type',      'Access-Control-Allow-Methods': 'PUT,POST,GET,DELETE,OPTIONS',      'Content-Type': 'application/json; charset=utf-8'    &#125;)  &#125;  req.method === 'OPTIONS' ? res.status(204).end() : next()&#125;)</code></pre><h2 id="vue-端："><a href="#vue-端：" class="headerlink" title="vue 端："></a>vue 端：</h2><pre class=" language-lang-javascript"><code class="language-lang-javascript">import axios from 'axios'import qs from 'qs'axios.defaults.withCredentials = true // 允许跨域设置，不然可能因为拿不到cookie而报错axios.defaults.baseURL = 'http://localhost:3000/' /*这里的地址就是刚刚启起来的服务器地址,就是node端服务器的地址 *//*请求拦截*/axios.interceptors.request.use(  config => &#123;    if (config.meth === 'post' && !(config.data instanceof FormData)) &#123;      config.headers = &#123;        'Content-Type': 'application/x-www-form-urlencoded'      &#125;      config.data = qs.stringify(config.data, &#123;        arrayFormat: 'repeat'      &#125;) /*这里是，后端要求传数组的时候做的设置，以前出过错*/    &#125;    return config  &#125;,  error => &#123;    return Promise.reject(error)  &#125;)/* 响应拦截 */axios.interceptors.response.use(  res => &#123;    /*可在这里根据返回的状态码做一些拦截操作*/    return res  &#125;,  err => &#123;    return Promise.resolve(err)  &#125;)export default axios /*记得导出*/</code></pre><p>这两个设置完之后应该就不会出现跨域的问题，反正我测试的接口现在可以用 axios 请求到数据了，虽然我不是非常理解为什么这样写。但是有需求急迫解决这个问题的可以借鉴一下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2021/10121.html"/>
      <url>/2021/10121.html</url>
      
        <content type="html"><![CDATA[<h1 id="javascript-的设计模式"><a href="#javascript-的设计模式" class="headerlink" title="javascript 的设计模式"></a>javascript 的设计模式</h1><h2 id="模块化模式"><a href="#模块化模式" class="headerlink" title="模块化模式"></a>模块化模式</h2><p>模块化模式：让内部成员不外泄到全局中，将内部信息封装成一个模块。只能通过特定的方法才可以进行访问内部成员信息。比如说购物车中数组是不能直接让外部进行访问的，只能通过其域中特定的方法才可以进行访问。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var buy = (function () &#123;  var buyList = []  //增加购物车数据方法  function addItem(values) &#123;    buyList.push(values)  &#125;  //得到购物车数据数量的方法  function getItem() &#123;    conlose.log(buyList.length)  &#125;  return &#123;    addItem: addItem,    getItem: getItem  &#125;&#125;)()buy.addItem(&#123;  name: 'one',  price: 1&#125;)buy.addItem(&#123;  name: 'two',  price: 2&#125;)buy.getItem() //2console.log(buy.buyList) //这个是不可以直接访问的,直接访问的结果是undefined</code></pre><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式是一种十分常用但却相对而言比较简单的设计模式。它是指在一个类只能有一个实例，即使多次实例化该类，也只返回第一次实例化后的实例对象。单例模式不仅能减少不必要的内存开销, 并且在减少全局的函数和变量冲突也具有重要的意义。<br>使用闭包实现单例模式</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let Create = function () &#123;  let instance = null  return function (name) &#123;    this.name = name    if (instance) &#123;      return instance    &#125;    return (instance = this)  &#125;&#125;Create.prototype.getName = function () &#123;  console.log(this.name)&#125;let xiaoming = new Create('xiaoming')// console.log(xiaoming.getName());xiaoming.getName() //xiaominglet xiaoliu = new Create('xiaoliu')// console.log(xiaoliu.getName());xiaoliu.getName() //xiaoming</code></pre><p>利用一个变量 instance 判断是否已经创建实例，如果之前没有创建实例就将 this 传给 instance。当第二次创建实例的时候，虽然向构造函数中传入参数了但是因为 instance 已经存在 所以返回的还是上一次创建的实例。</p><h2 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h2><p>寄生式组合继承相对来说是最为好的一种继承方式</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//让子类原型继承父类原型function inheritObject(o)&#123;  //创建一个过渡函数对象  function F()&#123;&#125;  //让F的原型对象继承父类原型对象  F.prototype=o  //返回F实例，这个实例继承了父对象的原型  retun new F()&#125;//寄生式继承function inheritPrototype(subClass,superClass)&#123;  //创建父类原型副本，存储在变量中  var p=inheritObject(superClass.prototype)  //修正因为重写子类原型导致子类的 constructor属性被修改  p.constructor = subClass  //子类原型继承父类原型  subClass.prototype=p&#125;//构建父类构造对象function SuperClass(name)&#123;  this.name=name  this.colors=['red','black']&#125;//父类原型对象方法SuperClass.prototype.getName=function()&#123;  console.log(this.name)&#125;//构建子类构造对象function SubClass(name,time)&#123;  //继承父类构造  superClass.call(this,name)  this.time=time&#125;//子类原型对象方法SubClass.prototype.getTime()&#123;  console.log(this.time)&#125;//创建子类实例对象var instance1=new SubClass('app book',2020)var instance2=new SubClass('css book',2021)instance1.colors.push('blue')console.log(instance1.colors)//['red','black','blue']console.log(instance2.colors)//['red','black']instance2.getName()//css bookinstance2.getTime()//2021</code></pre><p>一开始我对 p.constructor = subClass 这句话有歧义，因为我感觉去掉也是可以的。但是我上网查询了一下资料。不把 constructor 指回子类是可以的，但是后面添加原型方法就会出现问题。constructor 一般在闭包不能直接访问的情况下可以通过 constructor 进行添加一些方法。</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>当我们实现登录功能的时候，我们可能会用到警示框，提示框各种有些区别的框框。我们第一个想到的是将其封装成一个一个方法。但是只能一味的封装类，可能每一个框中有一些东西出现了差异之后，这时我们就需要再创建一个类。这实在是太麻烦了</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//自定义警示框 不使用工厂类创建//需求：需要一个警示框，错误提示框，确认框(确认框中需要添加一个注册按钮)var LoginAlert = function (text) &#123;  this.content = text&#125;LoginAlert.prototype.show = function () &#123;  //显示警示框  console.log('显示警示框')&#125;//警示框//需要创建一个新类var LoginComfim = function (text) &#123;  this.content = text&#125;LoginComfim.prototype.show = function () &#123;  //展示确认框&#125;//当内容又有一点差异时var LoginPromat = function (text) &#123;  this.content = text&#125;LoginPromat.prototype.show = function () &#123;  //展示&#125;//使用简单工厂模式var PopFactory = function (name) &#123;  switch (name) &#123;    case 'alert':      return LoginAlert    case 'confim':      return LoginComfim    case 'prompt':      return LoginPromat  &#125;&#125;var Factory = new PopFactory('alert')var alert = new Factory('警示框')console.log(alert.content) //警示框alert.show() //显示警示框</code></pre><p>当我们使用了这个工厂之后，再注册模块中也可以使用在完成登录模块时封装的方法。而且我们只需要记住这个工厂就好。<br>但是我们发现这封装的三个类中有很多相似点，所以我们遇到这种情况需要使用另一种工厂模式</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//另一种简单工厂化模式function createPop(type, text) &#123;  //创建一个对象，并对对象拓展属性和方法  var o = new Object()  o.content = text  o.show = function () &#123;    //共有方法  &#125;  if (type == 'alert') &#123;    //警示框差异部分    console.log('2警示框')  &#125;  if (type == 'prompt') &#123;    //提示框差异部分    console.log('提示框')  &#125;  if (type == 'confim') &#123;    console.log('确认框')  &#125;  return o&#125;var userNameAlert = createPop('alert', '另一种工厂警示框') //2警示框console.log(userNameAlert.content) //另一种工厂警示框</code></pre><h2 id="安全类，安全工厂方法"><a href="#安全类，安全工厂方法" class="headerlink" title="安全类，安全工厂方法"></a>安全类，安全工厂方法</h2><p>我们在使用类的时候如果不进行实例的话，可能就会出现问题。小白可能在实例化的时候忘记 new 关键字。这个时候就可能出现一些问题。所以我们需要使用安全类</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//不使用安全模式的类var Demo = function () &#123;&#125;Demo.prototype = &#123;  show: function () &#123;    console.log('成功获取')  &#125;&#125;var demo = new Demo()demo.show() //成功获取var demo2 = Demodemo2.show() //报错//安全模式类var Test = function () &#123;  if (!(this instanceof Test)) &#123;    return new Test()  &#125;&#125;Test.prototype = &#123;  show: function () &#123;    console.log('安全获取')  &#125;&#125;var d = Test()d.show() //安全获取</code></pre><p>我们上面说了怎样使用简单工厂模式，但是当我们需求过多的时候。我们不仅仅要添加类，还要修改工厂函数。这简直更加麻烦。所以我们这时候可以使用安全工厂方法</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var Factory = function (type, count) &#123;  if (this instanceof Factory) &#123;    //这时候使用者new了实例,返回对应的方法    let s = new this[type](count)    return s  &#125; else &#123;    //这时使用者没有new，应该构造一个工厂实例然后返回    return new Factory(type, count)  &#125;&#125;//添加工厂方法Factory.prototype = &#123;  java: function (count) &#123;    consloe.log(count)  &#125;,  javascript: function (count) &#123;    consloe.log(count)  &#125;&#125;var use = Factory('java', '使用java') // 使用java//我们使用的时候 无论使不使用new 都可以使用工厂中的方法</code></pre><p>当我们没有使用 new 的时候 这时候的 this 指向的 window 全局对象，所以 this instanceof Factory 这个就时 false 然后代码执行 else{} 返回了一个实例的 Factory 然后这时候的 this 指向的就是 Factory 了。然后 this 其实就是这个工厂构造，然后里面有这几个工厂方法.this[type]=this.java。 所以返回的 s 其实就是 java 这个方法了。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂更加体现类的继承关系。一般是先创建抽象工厂，然后创建具体抽象工厂，最后是产品。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//创建抽象工厂类var AbstractFactory = function (subType, superType) &#123;  //判断抽象工厂中是否有此具体抽象工厂  if (typeof AbstractFactory[superType] === 'function') &#123;    //创建缓存类    var F = function () &#123;&#125;    //继承抽象工厂类的属性    F.prototype = new AbstractFactory[superType]()    //指回    subType.constructor = subType    //子类继承父类    subType.prototype = new F()  &#125; else &#123;    return '没有此抽象工厂'  &#125;&#125;//创建具体抽象工厂AbstractFactory.Car = function () &#123;  this.type = 'car'&#125;//创建抽象产品类var BWM = function (price, speed) &#123;  this.price = price  this.speed = speed&#125;//继承父类(具体抽象工厂)AbstractFactory(BWM, 'Car')//抽象产品类的方法BWM.prototype.getPrice = function () &#123;  return this.price&#125;BWM.prototype.getSpeed = function () &#123;  return this.speed&#125;//创建具体产品var threeXi = new BWM('价格', '速度')conlog.log(threeXi.getPrice()) //价格conlog.log(threeXi.getSpeed()) //速度</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对象方法</title>
      <link href="/2021/10101.html"/>
      <url>/2021/10101.html</url>
      
        <content type="html"><![CDATA[<h1 id="js-object-的内置方法"><a href="#js-object-的内置方法" class="headerlink" title="js object 的内置方法"></a>js object 的内置方法</h1><h2 id="Object-assign-用法"><a href="#Object-assign-用法" class="headerlink" title="Object.assign()用法"></a>Object.assign()用法</h2><p>·对象的拷贝<br>该方法用于将所有可枚举属性的值从一个或多个源对象（sources）分配到目标对象（target），并返回目标对象。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let target = &#123; a: 1, b: 2 &#125;let sources1 = &#123; a: 2, b: 3 &#125;let sources2 = &#123; a: 3, b: 4 &#125;let obj = Object.assign(target, sources1, sources2)console.log(obj)//a:3 b:4</code></pre><p>注意：</p><p>1、源对象属性与目标对象属性不同，则会被拷贝到目标对象中;<br>2、如果目标对象和源对象有相同的属性，目标对象的属性值会被源对象的属性值覆盖掉;<br>3、如果有多个源对象有相同的属性，那么目标对象的属性将会被最后一个源对象属性覆盖。</p><p>使用这个方法进行拷贝进行的是深拷贝，继承和枚举的属性不可以使用 assign 进行拷贝</p><h2 id="Object-defineProperty-用法"><a href="#Object-defineProperty-用法" class="headerlink" title="Object.defineProperty()用法"></a>Object.defineProperty()用法</h2><p>·该方法允许精确地添加或修改对象的属性。通过赋值操作添加的普通属性是可枚举的，在枚举对象属性时会被枚举到（for…in 或 Object.keys 方法），可以改变这些属性的值，也可以删除这些属性。这个方法允许修改默认的额外选项（或配置）。默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改（immutable）的。<br>·使用方法:</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">const target = &#123;&#125;Object.defineProperty(target, 'foo', &#123;  configurable: false,  writable: false,  vakue: 'Test'&#125;)</code></pre><p>上面的代码就给 target 这个对象添加一个 foo 属性，而且这个属性的值为 Test。当 configurable 为 false 的时候这个属性不可以改变。当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符改变。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue-music-pc项目</title>
      <link href="/2021/092950482.html"/>
      <url>/2021/092950482.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue-music-pc-项目"><a href="#vue-music-pc-项目" class="headerlink" title="vue-music-pc 项目"></a>vue-music-pc 项目</h1><ul><li>这个项目是我自己动手做的第一个项目，完全靠自己做的，所以 css 写的不好，有一些逻辑写的也不是很好，后来再慢慢去优化吧，项目还没有上线。但是我的代码都放到了 GitHub 和 gitee 上了，一些东西还是有帮助的。</li><li>这里是 GitHub 的地址 <a href="https://github.com/wuyang147258/vue-music-pc">vue 网易云(github)</a> 这个是 gitee 的地址 <a href="https://gitee.com/ycwuyang/vue-music-pc">vue 网易云(gitee)</a> 这个是我用的后台接口 <a href="https://binaryify.github.io/NeteaseCloudMusicApi/#/">网易云后台接口</a></li><li>技术栈：vue+vuex+element-ui</li></ul><h2 id="开发前的准备："><a href="#开发前的准备：" class="headerlink" title="开发前的准备："></a>开发前的准备：</h2><ul><li>在我们进行痛快淋漓的写业务逻辑之前必然是需要配置一些插件依赖什么的。这里我 ui 框架是用的 element-ui 这个是开源的框架，功能还是比较齐全的。在 vue-cli 的使用方法我已经给大家找好了。<a href="https://blog.csdn.net/u013350495/article/details/103533320?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163288625116780264060046%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163288625116780264060046&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-103533320.first_rank_v2_pc_rank_v29&amp;utm_term=vue-ui%E6%8C%89%E9%9C%80%E5%AF%BC%E5%85%A5element-ui&amp;spm=1018.2226.3001.4187">按需导入 element-ui</a> 还有的就是 axios 库，这个比较简单安装一下就可以了。下面最重要的一点也是我踩过的坑，我最想给大家说的。就是在你访问后台接口的时候会出现跨域的问题，大家可能以前也遇到过满难受的。这是我用的解决方案源码：</li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">import axios from 'axios'import qs from 'qs'axios.defaults.withCredentials = true // 允许跨域设置，不然可能因为拿不到cookie而报错axios.defaults.baseURL = 'http://localhost:3000/' /*这里的地址就是刚刚启起来的服务器地址  *//*请求拦截*/axios.interceptors.request.use(  config => &#123;    if (config.meth === 'post' && !(config.data instanceof FormData)) &#123;      config.headers = &#123;        'Content-Type': 'application/x-www-form-urlencoded'      &#125;      config.data = qs.stringify(config.data, &#123;        arrayFormat: 'repeat'      &#125;) /*这里是，后端要求传数组的时候做的设置，以前出过错*/    &#125;    return config  &#125;,  error => &#123;    return Promise.reject(error)  &#125;)/* 响应拦截 */axios.interceptors.response.use(  res => &#123;    /*可在这里根据返回的状态码做一些拦截操作*/    return res  &#125;,  err => &#123;    return Promise.resolve(err)  &#125;)export default axios /*记得导出*/</code></pre><p>解决了以上问题之后我们就可以愉快的进行项目开发了！！!</p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>登录功能的思路很简单。第一先设置一个路由导航，阻止用户不进行登录就进入主页。第二获取后台接口进行登录(我使用了手机验证码登录和密码登录)，成功登录之后需要获取一个登录状态要不然后面的一些功能可能没有办法使用。</p><h2 id="歌曲实现播放"><a href="#歌曲实现播放" class="headerlink" title="歌曲实现播放"></a>歌曲实现播放</h2><p>在 pc 端上面怎么实现歌曲播放呢，我首先想到的是 audio 标签。然后就想要将音乐的 url 放到 audio 的 src 上应该就可以进行播放了。这是我当时写的时候的思路。因为组件的复用，所以我把 audio 放到了主页上，这样不管以后再增加什么歌曲或者歌单将这个歌曲的 id 存入到 vuex 中就可以拿到歌曲的 url，然后通过 ref 就可以设置 audio 的 src 进行歌曲的播放了。组件的复用还可以，省了不少麻烦。</p><h2 id="歌曲详情页面-歌词滚动实现"><a href="#歌曲详情页面-歌词滚动实现" class="headerlink" title="歌曲详情页面(歌词滚动实现)"></a>歌曲详情页面(歌词滚动实现)</h2><p>因为其他的东西不算特别难，业务逻辑基本都是一样的都是获取后台接口的数据然后进行渲染，没有什么稀奇的东西。我感觉这个歌词的滚动还算比较难，因为我在做的时候费了不少力气，也看了不少人的博客。这个解决方案是我看一个教学视频上看到的。<br>思路就是将后台获取到的歌词数据处理成一个时间段一句歌词的格式。然后获取当前歌曲播放的时间让这个时间大于上一句歌词的时间小于下一句歌词的时间，思路就是这样。下面附上歌词处理的代码，后面还要加上 css 的动画滚动。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//这里是处理歌词格式和实现歌词滚动的代码//处理歌词方法       formatTimeToSec(value)&#123;                    let arr = value.split(':');                    return (Number(arr[0]*60) +  Number(arr[1])).toFixed(1);            &#125;,   //处理歌词方法   proLyric(lyric)&#123;     //利用正则处理歌词                        // console.log(lyric)                        let re=/\[([^\]]+)\]([^\[]+)/g                        var result=[];                        lyric.replace(re,($0,$1,$2)=>&#123;                            result.push(&#123;"time":this.formatTimeToSec($1),"lyric":$2&#125;)                        &#125;)                        this.songLyric=result   &#125;,   //实现歌词滚动   //实现歌词滚动            listenLyricIndex()&#123;                //清除之前存在的计时器                clearInterval(this.timer)                this.timer=setInterval(()=>&#123;                    for(var i=0;i<this.songLyric.length;i++)&#123;                        if(this.$store.state.currentTime>this.songLyric[this.songLyric.length-1].time)&#123;                            this.lyricIndex=this.songLyric.length-1                            break;                        &#125;                        if(this.$store.state.currentTime>this.songLyric[i].time && this.$store.state.currentTime<this.songLyric[i+1].time)&#123;                            this.lyricIndex=i                        &#125;                    &#125;                &#125;,500)            &#125;,            //关闭定时器            cancelLyriIdex()&#123;                clearInterval(this.timer)            &#125;,</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客小试牛刀</title>
      <link href="/2021/092839553.html"/>
      <url>/2021/092839553.html</url>
      
        <content type="html"><![CDATA[<h1 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h1><h2 id="一个前端小白的成长经历"><a href="#一个前端小白的成长经历" class="headerlink" title="一个前端小白的成长经历"></a>一个前端小白的成长经历</h2><ul><li>见证了自己的成长，真的很幸福。从大一到现在一直一个人在自学，到现在可以做一些<br>有趣的东西，可以做一些好玩的东西感觉真好。虽然自己出了很多 bug，但是基本上也都<br>上网进行了解决，也有看见困难就退缩的时候，比如这个博客一开始我就没有搭建好，<br>然后放弃了搭建。几天后我又重拾进行搭建。现在终于成功了，所以不是办不到，只是<br>看自己想不想干了。</li></ul><h2 id="可爱的小猫"><a href="#可爱的小猫" class="headerlink" title="可爱的小猫"></a>可爱的小猫</h2><p>以后在能养活自己的前提养一只小猫！<br><img src="https://th.bing.com/th/id/R.f18f12a4ba5ae21a01bd8a8ecae7fa42?rik=5S8Pjv29%2fYLEnA&amp;pid=ImgRaw&amp;r=0" alt=""></p><h2 id="vue-网易云"><a href="#vue-网易云" class="headerlink" title="vue 网易云"></a>vue 网易云</h2><p>这是自己做的 pc 端网易云，完全自己做。我样式搞得不是很好，需要重新加工。<br>这是 GitHub 地址 <a href="https://github.com/wuyang147258/vue-music-pc">vue 网易云</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 成长经历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/092816107.html"/>
      <url>/2021/092816107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
